{"transpiled":true,"noir_version":"0.32.0+92ff2fa2e944722e5c3fa43fb3363f093b8f1d12","name":"TokenBridge","functions":[{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/83YS2/TQBAH8HXSpi2JX3k1duzESWxy4EIPcOXGEXFGQoiXKgQCIcoBPiKfip3ZHf/jGiwtqiIsOXZn55cZb2xroVR9pc71rlSu7NbTERWogT54tD9RcmYGlRcoT0IVDbKqbJrqb/XHvUq+qveIBtiFFDvhz9MHfE5neh+UyiN6ckrfTKXNUEntKQIXlbR3pjhI2wV9mBxi5yVG9Bc+ozZM8plNHlY9E1RDsKHJuTCnTL8gLHTElBJGoCPQkaU3CAv1mVKCD+qD+pYWCAsNmFJCABqABpZ+QFhoyJQSQtAQNLT0M8JCI6aUEIFGoJE5tkngTkZ3XkVf02uEhcZMKSEGjUFjSz8hLHTMlBLGoGPQcbvRcd1oB9HVfiIsdMKUEiagE9CJpe8RFjplSglT0Cno1NJ3CAudMaWEGegMdEbHDT1aN3gwI4YKT6M8fpStKnlE9TeeKGxzLjVvlro0eGZOZYRuwUskJXjA0wGfpjZ/aV8gmceJGYVo546/mr/kcslklaQtUNgM9EyQBqVCQkd6Oq8P2rrV8GNP7kHbyql5l/XxiqPTh4132fyv77JZ8132FBXnNnnBnVLtBdgCv9jC0u8IC03qi0wOJhc0wa/ZJGE30dXeIiw0ZcpzCJqCpu1qaf1qcCSBOxm6k9Cd+N1Ez9w1wkKXTFNzfwtdgi7b1Zb1K8CRjLqJbvAVwkLN00IJGWgGmrWrZXU1RzLsJrrBjwgLzZlSQg6ag+btank9g44kdCe+O0ncSfS/XsvwKI3F3UTfOD8QFrpiSgkr0BXoql1tVU9DB9HV3iAsdM2UEtaga9B1u9q6vk0die9OEncSuZP4KOQfZmx655Os74JvCAstmFJCAVqAFu1qRf02dSTRUaoE7iQ5yrXERyF5N6HFqfcSa8Mrhn9YTheN5XTRXE5vuNSmWWprcGFOZYQWn1sklVhjVmY5Xdn8+3YNuzfL6T2FaOeOX5i/5HLJ7CtJ26GwGeiZIA1KhZKOOsN7ftDWrYbr5fRVycvnw42X1fwfFGz6B5ddz94As7dtrqw3+56FHqaett3BzJjp2EmzfN30b+yK+7Jb39ThtIpnoKp72PIvo+wv09vR6eIX7b8BjQdIV3MRAAA=","debug_symbols":"5ZzvSlxXHEXfZT6Hcs/e56+vUkoxiSmCaIimUKTv3rGO2tABWYQdmPgpGT2/wz0uFsjycO93Hy/ef/3j98vrTze3u7Nf73dXNx/O7y5vrvef7nfbL2X796u3n8+vH75we3f+5W53tr3bXVx/3P/797vdp8uri91Z3//3f8tWa4eFa4znpaX4yNpq9cPiareX1epHVvfa1mF1r+Pb1b+9e3ju8h3PXTbrsLJsrf7gJ9f3/MRXeXnw9sqDF231abX69sqDj77GYfUYdTvy4M48+OPmNbl5S27ek5uP5OYzufkKbq4tuXlJbq7k5klDlTRUSUOVNFRJQ5U0VElDnTTUSUOdNNRJQ5001ElDnTTUSUOdNNRJQ2vS0Jo0tCYNrUlDa9LQmjS0Jg2tSUNr0tCaNLQlDW1JQ1vS0JY0tCUNbUlDW9LQljS0JQ1tSUN70tCeNLQnDe1JQ3vS0J40tCcN7UlDe9LQnjR0JA0dSUNH0tCRNHQkDR1JQ0fS0JE0dCQNHUlDZ9LQmTR0Jg2dSUNn0tCZNHQmDZ1JQ2fS0Jk0dCUNXUlDV9LQlTR0JQ1dSUNX0tCVNHQlDV1JQ8u2RXcv0d0V3T16a2Gr0d2j9xa26MWFLXpzYYteXdiirpaoqyXqaom6mr1hlL1ilL1jBC4ZHQYGHZh0YMEBcGnnMFDogOiA6UClA40OUNKipEVJi5I2JW1K2pS0KWlT0qakTUmbkjYlbUq6UtKVkq6UdKWkKyVdKelKSVdKulLSlZJulHSjpBsl3SjpRkk3SrpR0o2SbpR0o6Q7Jd0p6U5Jd0q6U9Kdku6UdKekOyXdKelBSQ9KelDSg5IelPSgpAclPSjpQUkPSnpS0pOSnpT0pKQnJT0p6UlJT0p6UtKTkl6U9KKkFyW9KOlFSS9KelHSi5JelPSCpLVtdKDQAdEB04FKBxod6HRg0IFJByjpQkkXSrpQ0oWSLpR0oaRpIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYyH29k+98dn16wuf8lT/8dO/KayrI9vXiylFaeF5d27DWVrc2n1a3rZevjL7Vs1c+ra/crq+doT2/6nHMr36x+PO7xYPfzHldv67h+W8etb+u47W0dt//w4w69HPe1A5TSX/Ye/WX1eH7h4Dj1A8xTP8A68QMc/zPNKR2gnPoBdLoH2H/68/zL5fn7q4uHt+U/fPPr9Yenl+fvP9799fnxO/u1/wA="},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3hruS4kaXfpX8bBhkMMsh5lcVi4ZnxLAwY9mDsWWBh+N1HwVvSvdWlzOzKVDBPiPrlbrd0z8dkkhFJKeL845d//+O//vf//T9/+st//PVvv/zL//rHL3/+67/94e9/+utfln/7xy+R+//3t//8w1/0X//29z/8199/+Zfwu1/++Jd/X/73n7/75T/+9Oc//vIvZfnHHy6jkuTblVRy2y6O3HauTiL129Wpcn5wdcshf7u65cLb1VTT7tXl28UxhC8Xyz//9+9+iXmCMZZhY2QK69VMRQaOUV4YY2ohrTPT0pcxxo+/XQ3/dnvhby9/g9ePhL7723ufX1wmZ706p/Lgaiq1rfNeQ3s4N4fNJIVXPhGq2yeSEj0YY27rxSV9WY/LfcoRQTgIhCOBcDAIRwbhKCAcAsJRQTgaBkcauJ+WuHKw/MARQTjG7aeS1jgnNfzAMW4/bWG9uH29Vv/5h2tLCttn9/ldolL2KHJds71YQvnuah0hn36E+fQjLP5HWGLcRpjyDyOU04+wnn6E7QQj5O3XWSnh1yPkcPoRxtOPkM4QLcrnCOMPIwTNadq6eUhKD0ZI0sJ27pHCrw4nmM8+wHEZTQx129Mj5wdDzGk9PP16vpR4P1isf7fWz/FxH185+fjk5OOrJx9fO/f4cjj5+OLJx0cnH186+fj45OM7ef6ST56/5JPnL/nk+Us+ef5STp6/lJPnL+Xk+Us5ef5S+OTjO3n+Uk6ev5ST5y/l5PlLOXn+IifPX+Tk+YucPH+Rk+cvwicf38nzF0HNX4TWF7AlydfxKTRqUnIXGjXTqNvz8lrj/W/S/WetgpprHDbCipptHDdC1HzjuBGiZhzHjRA15zhuhHz6EaLmHceNEDXzOG6EqGnKcSM8fU5TT5/TtNPnNO30OU07fU7TTp/TND79CE+f07TT5zTt9DlNO31O006f08Rw+qQmhtNnNTGcPq2J4fR5TQx8/iGePrOJ4fSpTQynz20W2fMP8fzZTTx/dhPPn93E82c38fzZzUtNJZ0M8fzZTTx/dhPPn93E82c38fzZDZ0/u6HzZzd0/uyGzp/dDGxO+rYhnj+7ofNnN3T+7IbOn93Q+bObdP7sJp0/u0nnz27S+bObgQ193zbE82c36fzZTTp/dpPOn92k82c3fP7shs+f3fD5sxs+f3YzsLfv24Z4/uwGtsHvgUM8f3YD2+b3wCGeP7uBbfZ74BDPn93Atvw9cIjnz25gG/8eOMTzZzew7X8PHOL5sxvYJsAHDvH82Q1sK+ADh3j+7Aa2IfCBQzx/dgPbFvjAIZ4/u4FtDnzgEM+f3cC2CD5wiOfPbmAbBR84xPNnN7Dtgg8c4vmzG9imwQcO8fzZDWzr4AOHeP7s5vxtieP5+xLHoY2JSW4NsaPsZiFUmFZ+CQ+AiMLqykzEn0CJ9oDa50celHj9ZHZboae2+T1z+u7izk6O2ZNjdnbMnh2zF8fs4pi9OmZvftn3e906YXccV5vjuNocx9XmOK42x3G1OY6rzXFcbY7javMbVyn4jasU/MZVCn7jKgW/cZWC37hKwW9cpeA3rlLwG1cp+I2rFBzH1eg4rkbHcTU6jqvRcVyNjuNqdBxXo+O4Gh3H1eg4rkbHcZUcx1VyHFfJcVwlx3GVHMdVchxXyXFcJcdxlRzHVXIcV9MRcbXIxl7bQPbomJ0csyfH7OyYPTtmL47ZxTF7dcze/LKz47jKjuMqO46r7DiusuO4yo7jKjuOq+w4rrLjuMqO42p2HFez47iaHcfV7DiuZsdxNTuOq9lxXM2O42p2HFez47haHMfV4jiuFsdxtTiOq8VxXC2O42pxHFeL47haHMfV4jiuiuO4Ko7jqjiOq+I4rorjuCqO46o4jqviOK6K47gqB8TVRFuTo5QHstfgmD06ZifH7MkxOztmz47Zi2N2ccxeHbM7jqvNcVxtjuNqcxxXm+O4ekS/pbexO46rzXFcbY7janMcV5vfuJqC37iagt+4moLfuJqC37iagt+4moLfuJqC37iagt+4moLfuJqC47gaHcfV6DiuRsdxNTqOq0f0W3obu+O4Gh3H1eg4rkbHcTU6jqvkOK6S47hKjuMqOY6rR/Rbehu747hKjuMqOY6rR/RbkvR58WP21L5d3MrnH6aaPnAaFM4RXZGOxIlYOISFsx92JKVNQR4uw7KuLMr0eXEsdedqyav5Xq1fvPd2XQBbDnllz4W/g9+7eluzIXy5WD4GyrMMNA8e6PK12nAqfzfSzlPAeGQwT8xhA8pfluv+VyESbe6US1T7nN1Q9kgy141E4v2olrit78qm5Qv3efHel2yJresms/xj/Xpx/xTr9Ske8Cm261N8/VO80S7q+hR/7lOM16f4Wz7FtIXqJZeLP3yKdH2KB3yK6foUf9OnmMr2KeZ4/2Kqsn0gtaYHFy/P17af1vTjXsHX/Lx5fmT7Cchffi/uXix5HZ80/vVZBudrKs8yleWayrNM5fUj9c1TyXE7W+ZUX5nK65fyaaby+rn+5qn8/DwoJ/l1WpqvgwDs+bmOGLDn5zq8wJ6f61jkzfNTPj/qInT/4ljL9nHUmn+YTL4m8zyTeZ2iOJpMCmH7y4HaC78I8nXkMue8X+czc877dZjjat5T3ua9pFfm/Tr5mXLey3WidPy8t7C1bGzxwW784EF0uU6U3j0/Rz3yKtfh02mm8jqnevNUHvbIq1ynVKeZyuuM6s1Tef90v1xnSdjzc535YM/PdTaDPT/XGcqb5+fAB15yHYycaDKvUxRHk3nc0wy5jlzmnPfrfGbOeedr3j3N+1FPseQ6+Zlz3q8TJYN5r1vlcoj1tbz7OlHCnp/rROm983Ng6nMdPp1lKut19HSaqbwOnk4zlddZ0run8qifDfU6HjrNVPI1lb9lKnmjThwfXHxkI6V6ncy8e36OeumxXoctp5nK61zmNFN5HeG8eSoPe3+1Xkc4Z5nKdh3hvHkq77+q165zGez5uQ5bsOfnOkHBnh++5ue983Pg26vtOkM50WRepyiOJvO4x0ftOnKZc96v85k55/06zHE17wc9kFyGc837lPN+nSgdP+/HNVLicJ0ovXt+DnrkxeE6fDrNVPI1le+dyqMeeXG4TqlOM5XXGdWbp/Lu6T6H6ywJe36uMx/s+bnOZqDnJ15nKG+en+MeeHG8DkZONJnXKYqjyTzsaQbH68hlznnna96nnPfrMMfVvB/1FCteJz9zzvt1omQw74c16uF4nShhz891ovTe+Tku9aHr8Ok0U3kdPZ1mKq+Dp9NM5XWW9O6pPOpnA/E1lWeZyvEnPm3tLhVLCV6mctn81osp/PCWKZXrUzzgU5TrUzzgU6zXp3jAp9iuT/E39QoMW9RKFH/9KaZwfYoHfIrx+hTfa9J+v8Yk0TU/b56fowoTUrqm8ixTyddUnmUqrx+pb57Kw2pM0vVL+TRTef1cf/NU3n+dPl0HAdjzcx0xQM8PX4cX2PNzHYu8eX4OrDDh6wzlRJN5naI4mszjXvFgvuZ9ynm/zmfmnPfrMMfVvB/10hBfJz9zzvt1onT8vB/Y7JCvE6V3z89Rj7zydfh0mqm8zqnePJWHPfLK1ynVaabyOqN681TeP93PfM0P9PxcZz7Y83OdzWDPz3WG8ub5OfCBV74ORk40mdcpiqPJPO5pRrmOXOac9+t8Zs55vw5zXM37UU+xynXyM+e88zXvx8/7cc30ynWihD0/14nSe+fnwNTnOnw6zVReR0+nmcrr4OksUynXWdK7p/Konw1yHQ+dZiqvE5/fNJV2Ju3331+V62Tm3fNz1EuPwtdUnmUqr3OZ00zldYTz5qk87P1VuY5wTjOV1xHOm6fy/qt6cp3LQM9PvQ5bsOfnOkHBnp/rWOTN83Pg26v1OkM50WTyNZl+JvO4x0f1OnKZc96v85k55/06zHE170c9kKzXyc+c836dKB0/7wc2UmrXidK75+eoR17tOnw6zVRe51RvnsrDHnm165TqNFPJ11S+dyrvn+636ywJe36uMx/s+bnOZrDn5zpDefP8HPjAq10HI6eZzGXZXpPpZzIPe5qRw3XkMue8X+czc877dZjjat4PeoqVA1/zPuW8XydKBvN+WKOeHK4TJez5uU6U3js/B6Y+1+HTaabyOno6y1TG6+DpNFN5nSW9eyqP+tkQr+Oh00zl8BOfso0zSmjfTWUHYjSgjAY0/EehxG09yZfHthuQoAFVNKDhGanUuv1ujT8CUUADGp4dSJFPoPojEKEBDd+p25b6xdbij0CMBpTRgAoa0OidmhJticqSDj1I3LitfzprqrZmKkQ717bt2hi+JmLLxX2kdZqRtllGmsJpRhrD9tJ2DLQz1DjPUGmeoaYTLdXPkebw40j5lCOVnTnN0CPNeS3ZKpwfjJRkGyrV9GVS5WOkZZqRjk+TwudI5eFI0/pTKpfPA539o7CNYnl8+euzn1TnGGabYpgc5hhmnGOYNMcw0xzD5DmGmecYZpljmHNkQTxHFsRzZEF5jiwoz5EF5TmyoDxHFpR5jmHOkQXlObKgPEcWlOfIgvIcWVCZIwsqc2RBZY4sqMyRBRWeY5hzZEFljiyozJEFlTmyoDJHFiRzZEEyRxYkc2RBMkcWNNxV+E3DnCMLkjmyIJkjC5I5siCZIwuqc2RBdY4sqM6RBdU5sqDhroBvGuYcWVCdIwuqc2RBdY4sqM6RBbU5sqA2RxbU5siC2hxZ0HDfmTcNc44sqM2RBbU5sqCGnQXJViH4te1K+saOndrcYy8BO1+paa2frDXe/3rdr7UsATtjOXCg2DnLgQPFzloOHCjPMlDszOXAgWLnLgcOFDt7OXCg2PnLgQPFTnaOG2icJTOKs2RGcZbMKM6SGQ1v4vq2gc6SGcVZMqM4S2YUZ8mM4iyZEc2SGdEsmRHNkhnRLJnR8KbJbxvoLJkRzZIZ0SyZEc2SGdEsmVGaJTNKs2RGaZbMKM2SGb2hZfSbBjpLZpRmyYzA+0UfONBZMiPwntHHDRS8a/SBA50lMwLvHH3gQGfJjMC7Rx840FkyI/AO0gcOdJbMCLyL9IEDnSUzAu8kfeBAZ8mMwLtJHzjQWTIj8I7SBw50lswIvKv0gQOdJTMC7yx94EBnyYzAu0sfONBZMiPwDtMHDnSWzAi8y/SBA50lMwLvNH3gQGfJjMC7TR840FkyI/CO0wcOdJbMCLzr9IEDnSUzAu88feBAZ8mMwLtPHzjQWTIj8A7UBw50lswIvAv1gQOdJTMC70R94EBnyYzAu1EfONBZMiPwjtQHDnSWzAi8K/WBA50lMwLvTH3gQGfJjMC7Ux840FkyI/AO1QcOdJbMCLxL9YEDnSUzAu9UfeBAJ8mMZJYe2DJLD2yZpQe2zNIDWwLPMtBJMiOZpQe2zNIDW2bpgS2z9MCWWXpgyyw9sGWWHtgySw9smaUHtszSA1tm6YEts/TAlll6YMssPbBllh7YMksPbJmlB7bM0gNbZumBLbP0wJZZemDLLD2wZZYe2DJLD2yZpQe2zNIDW2bpgS2z9MCWWXpgyyw9sGWWHtgySw9smaUHtszSA1tm6YEts/TAlll6YMssPbBllh7YMksPbJmlB7bM0gNbZumBLbP0wJZZemDLLD2wZZYe2DJLD2yZpQe2zNIDW2bpgS2z9MCWWXpgyyw9sGWWHtgySw9smaUHtszSA1tm6YEts/TAlll6YMssPbBllh7YMksPbJmlB7bM0gNbZumBLbP0wJZZemDLLD2wZZYe2DJLD2yZpQe2zNIDW2bpgS2z9MCWWXpgyyw9sGWWHtgySw9smaUHtszSA1tm6YEts/TAlll6YMssPbBllh7YMksPbJmlB7bM0gNbZumBLbP0wJZZemDLLD2w6yw9sOssPbDr+B7YxO3WQDvQARlM5m3IudADICnrX15C0Oe1EneubWllb6U9uFZy3f4uf37s30bJU4zyRu4SN/DlFPr+KGOMtH67ln/mL1+YKLtfr1a3zzCFSN9d36EKItSNnKBtK6tye/B9YKq0Xs0pfs5GCm3n+rQ80/l2eaqcP5F47+qWt/2p5fJlpmvavbqsH08I/MOeU4cPlinIt8uZiowcbHs4WF2w9wabqK4XpxS+rF6KXeJW/+Wfktj2h32J+LpEiusUpBzCdxI7SyxXWhdkLIHjD0vmVo/idyKl0UglSNuQ4teJW5EYDykfixTzA6REvF38ZekTKU4Kv7/RGC+mLSOL7UscDGm9rzx5nzx5X33yvvbcfTd6dD2+Lz553/6Kps/MeMkvv7vvx7ku2xejSHtwbWxbBFyAvuzcpaxECY6I4YgyHFGBIxI4ogpH1NCIbnTieSdRhCOC27MZbs9muD2b4fZshtuzGW7PZrg9m+H27Ay3Z2e4PTvD7dkZbs/OcHt2htuzM9yeneH27DJ49WdZr83181qKGw+B8Qz+VpewHuGVL0dTX3gKGI+A8VQwnobFI6b5xzeNOEDjgH1C4nqxEO9ppAEaPEAjD9AoAzRkgEYdoHHAniB5fR5Ww+MsgD6zgCQ7WUANcEQRjojgiBIcEcMR5dFEOW9EZS/jrgWOSOCIKhxRQyNqAY4owhEN37O//N6ue/tRS3BEDEeU4YgKHJHAEVU4ovZGot3TthgCHlLEQzpg2660vSQs8vS1K1BCA2I0oIwGVNCABA2oogE1MKAY0IAiGhDaTh3RduqItlNHtJ06ou3UEW2njmg7dUTbqQltpya0nZrQdmpC26kJbacmtJ2aBu9Dj17OiNTAgNLgVfbocX9MCQ2I0YAyGlBBAzLNh1aROkAkE9h+kRMaEKMBZTSgggY0+OdKiethb6G0C1TRgBoYUAloQBENaHgi1TYg3gVKaECMBpTRgAoakKABVbBUszQwIAloQBENCO0nr6D95BVGA0L7yStoP3lF0IDQdmpB26kr2k5d0XbqirZTV7SduqLt1BVtp65oO3VF26kr2k5d0XbqhrZTN7SduqHt1A1tp25oO3VD26kb2k7d0HbqhrZTN7CdmgLYTk0BbKemALZTUwDbqSmA7dQUwHZqCmA7NYXBTSsePeKkGNCAwNrmUATrm0MxoQHxWKBHjzgpZjSgggYkaEAVDWh4e6H7TxSJAhpQRAMiNKCEBsRoQGBN4IjAusARgbWBIwLrA0cE1giOUkADimhAhAaU0IAYDQhtp05oO3VC26kT2k6d0HZqRtupGW2nZrSdmtF2akbbqRltp2a0nZrRdmpG26kZbafOaDt1RtupM9pOndF26oy2U2e0nTqj7dQZbafOUDt1yjesKCVu5sySvkjk7TZ57rb63G3tqdv2D1Ie3xafu42eu213m6txdR6ttH8bP3dbfu628txt8txt9bnb2lO37f+Iq5vvdm20e1t87jZ67rb03G383G35udvKc7ftfktaWF19Wwy7t9XnbmtP3bafQD6+LT53Gz13W3rutt1vSdvMj1vaXTj76cfj28pzt8lzt9XnbmtP3bZfPv74tvjgNt6dt/1S7Me3pedu2/+WbA1mW9ld3fvFx49vK8/dJs/dVp+7rT11237p6uPb9r8ldbOWD7l+d9/vfubiVYRGiKQRIjxCJI8QKSNEZIRIHSHSBojsFzUeLTJixdcRK76OWPF1xIqvI1Z8HbHi64gVX0es+DpixbcRK76NWPFtxIpvI1Z8G7Hi2+vr5P470KpR7TVuGEr8lMjD88QbFhFHi6QRIjxCJI8Q+dlwst0oT95IacD3mXiESB4hUkaIyAiR1zey++/Wd5E2QCSFESJxhAiNEDliS773uncX4REieYRIGSEiI0TqCJE2IExyGCEyIgnjEUkYj0jCeEQSxiOSMC4jRGSESB0hMmLF5xErPo9Y8XnEis8jVnweseLziBWfR6z4PGLF5xErPo9Y8WXEii8jVnwZseLLiBVfRqz4MmLFlxErvoxY8WXEii8jVryMWPEyYsXLiBUvI1a8jFjxMmLFy4gVL9YrnuPvdyWWPGmzhM7yqUF77xrXsvei3+6lMday/l36eqDEK07FwmlYOPttl97IE8F4CIwngfEwGE8G4ylgPGC7cwTbniPY/kxg+zOB7c8Etj8T2P5MYPszge3PZLg/rxJiL/H6Ltoifbu2cXz5U21YPCmA8UQwHgLjSWA8DMaTwXgKGI+A8YDtzwlsf2aw/ZnB9mcG258ZbH9msP2ZwfZnBtuf2XB/XiWqvUQzl8jBXiLaS5C9RLKXYHuJbC9R7CXsV3d5/Usbw9bPI4avu9SnCI0QeX3KI2XZ9lvZOx8obcBIJIwQGTHxwgeIfHmm2mRPJI8QKSNEZIRIHSFyxDoR+hSpOyI1jBCJI0RohEgaIcIjRPIIkTJCREaI1BEiB6z4Jf6uF8e8l620MEIkjhChESJphAiPEMkjRMoIERkhcsCKj1uTuBhb2xNpA0RiCENU0oAfDzfK1w9XyUNUyhCVNkLlgHf3fotKHKJCQ1Ts10vaf/9VtrukPjg+5bDSMOX7l9YtvWnhS7krP3Eom/ZflHXA3Zxy7y9fD+DRKzh5BU9ewdkrePYKXryCe42b0WvgjF4jJ3mNnOQ1cpLXyEleIyd5jZzkNXKSWeRcBcRa4OVItHUO58x7As1YIAVrgWgtQNYCL+9odV00XNOeAFsLZGuBYi3w6krOYWt/GOqeQLUWaMYCHKwForXAq1/TTGvEybQrUKwFXp3kkrZ2ennvqDMHawHrjyi/vJJ5+xZl2ROo1gLNWKAEa4FoLUDWAslagK0FsrVAsRY4cCWXsidQrQVeX8nbZid7AvLySt626xsC0VqArAVeXcklbP2NQ9sTYGuBbC1QrAXEWuDlldzWN1nKFyO8LwLNWKAGa4FoLUDWAslagK0FsrVAsRaQAwX2VnKt1gKvr+S12KDQnkB7eSVv55o3BKK1AFkLvByTH/zKbGwtkK0FirWAWAtUawHrw5Ab73wepZBvvFkWC2+v1Zbvf1fsPAXhuD0FYdrTuPFS4c+J5LaJ1AcXH9fNJ996M8kLPHmGT57h2TN89gxfPMOLZ/jqGb45hifPEZY8R1jyHGHJc4QlzxGWPEdY8hxhyXOEJc8RllAi7DeehBI0V57BcfC49lv51jtqXuCTZ3j2DJ89wxfP8OIZvnqGb47hOXiG9xxh2XOEZc8Rlj1HWPYcYdlzhGXPEZY9R1j2HGEzSoRdeVCC5sqDEgdXHpTQtvKgRKuVByUArTwoMWXlQQkTKw/Kzr/yoGzm33gK2P5cBq/3B72O863Cj7cSDf5OP+jolW+VNbzzMxKCI0pwRGU00d320vlWYcNbiSocUUMjqgGOaPh+dLeNcr5VzfFWogRHxHBEGY6owBEJHFGFI2poRC3AEY3es+9328636nbeSpTgiBiOKMMRFTgigSOqcEQNjehWz3xDpLsN9jtSxEMiPKSMdmJzq8//W5EEDwnuqC2OLuH7LUiEh5TwkBgPCWtfKsGnN8TC7bLF9cLtssP1wu3TG0LBXXa4VnCXHa4V3GWHawVnr+AuO1wruEtvCAX3Gjd9ekMouNfI6dMbQsG9Rk6f3hAK7jVy+vSGUHCvkdPWG0IFxFrA1BtCBZqxgK03hApEawGyFjD1hlABthbI1gLFWsDUG0IFqrVAMxaw9YZQgWgtYOoNoQLFWsC0HeIiYOsNoQLWH5GtN4QKVGuBZixg6w2hAtFagKwFkrUAWwtka4FiLWDqDaEC1VrA1BtCn0yZekOoQLQWIGsBU28IFWBrgWwtUKwFxFrA1BtCBZqxgK03hApEawGyFkjWAmwtkK0FirWAqTeEClRrAVNvCH17wdQbQgWitQBZC5h6Q6gAWwtka4FiLSDWAtVawPowxNgbojR7b4hFw683hMK77Vyt8G47Vyu8287VCs+e4d12rlZ4t52rFd5t52qFd9u5WuHdekMs8H69IRTec4T16w2h8J4jrF9vCIX3HGH9ekMovOcI69cbQuGRvCEWHihvCOVx27la4d12rlZ4t52rFZ49w7vtXK3wbjtXK7zbztUK77ZztcK77Vy9wPv1hlB4zxHWrzeEwnuOsH69IRTec4T16w2h8J4jrF9vCIX3HGGhvCGUB8kbQnmQvCGUB8kbQnlQotXKg+QNoTxI3hDKg+QNoTxI3hDKg+QNsfBAeUMoz+D1/qCDvhJheUMoEVbDOn3vCssbQomwvCGUCMsbQomwvCGUCMsbQomwvCGUCMsbYiEC84ZQIixvCCXC8oZQIixvCCViOCIsbwglwvKGUCIsbwglwvKGUCIsb4iFCMwbQomwvCGUCMsbQomwvCGUiOGIsLwhlAjLG0KJsLwhlAjLG0KJsLwheuURljdER8LyhuhIWN4QHQmsB3uD84boSFjeEB0J7qgNzRuiI2F5Q3QkLG+IjsR4SFj7khT7Ct5Fw28Fr8K7rS9SeLf1RQrvtr5I4dkzvNv6IoV3W1+k8G7rixTebX2Rwrut4F3g/VbwKrznCOu3glfhPUdYvxW8Cu85wvqt4FV4zxHWbwWvwiNV8C48UBW8yuO2vkjh3dYXKbzb+iKFZ8/wbuuLFN5tfZHCu60vUni39UUK77a+aIH3W8Gr8J4jrN8KXoX3HGH9VvAqvOcI67eCV+E9R1i/FbwK7znCQlXwKg9SBa/yIFXwKg9SBa/yoESrlQepgld5kCp4lQepgld5kCp4lQepgnfhgargVZ7B6/1BnaMSYVXwKhHWa4X63hVWBa8SYVXwKhFWBa8SYVXwKhFWBa8SYVXwKhFWBe9CBFbBq0RYFbxKhFXBq0RYFbxKxHBEWBW8SoRVwatEWBW8SoRVwatEWBW8CxFYBa8SYVXwKhFWBa8SYVXwKhHDEWFV8CoRVgWvEmFV8CoRVgWvEmFV8PbKI6wK3o6EVcHbkbAqeDsSXKUcWgVvR8Kq4O1IcEdtaBW8HQmrgrcjYVXwdiTGQ8Lalyr//lUfZA7126VM+f6ldftF0gJ/Xso//5x74a5OuZtT7hi8gkev4OQVPHkFZ6/g2St48QruNW5Gr4Ezeo2c5DVyktfISV4jJ3mNnOQ1cpLXyElmkXMVEGuBlyNRXo8BOfOeQDMWSMFaIFoLkLXAyztaXRcN17QnwNYC2VqgWAu8upJzWC/Noe4JVGuBZizAwVogWgu8+jXNtEacTLsCxVrg1UkuaT0YLXnvqDMHawHrjyi/vJJ5+xZl2ROo1gLNWKAEa4FoLUDWAslagK0FsrVAsRY4cCV//8RoFajWAq+v5G2zkz0BeXklb9v1DYFoLUDWAq+u5BLW9L2EtifA1gLZWqBYC4i1wMsrua1Pl0sMewLNWKAGa4FoLUDWAslagK0FsrVAsRaQAwX2VnKt1gKvr+S1hK3QnkB7eSVv55o3BKK1AFkLvByTH/zKbGwtkK0FirWAWAtUawHrw5Ab7zYfpdDY3huisWNviMaOvSEaO/aGaOzYG6KxY2+Ixo69IRo79oZo7NgborFjb4jGjr0hGjv2hmjs2BuisWNviMaOvSEaO/aGaOzYG6KxY2+Ixo69IRo79oZojOUN0RjLG6KxY2+Ixo69IRo79oZo7NgborFjb4jGjr0hGjv2hmjs2BuisWNviMaOvSEaO/aGUHjPEdavN4TCe46wfr0hGjv2hlB4zxHWrzdEY8feEI2xvCGUB8kbQnmQvCGUB8kbQnlQotXKg+QN0RjLG6IxljdEYyxviMZY3hCNsbwhGqN5QzRG84ZojOYN0RjNG6IxmjdEYzRviMZo3hCN0bwhGqN5QzRG84ZojOYN0RjNG6IxmjdEYzRviMZo3hCN0bwhGqN5QzRG84ZojOYN0RjNG6IxmjdEYzRviMZo3hCN0bwhGqN5QzRG84ZojOYN0RjNG6IxmjdEYzRviMZw3hAdCcsboiNheUN0JKwe7B0JyxuiI2F5Q3QkuKM2NG+IjoTlDdGRsLwhOhLjIUHtSxyiS28I5fbY4lq5PXa4Vm6X3hAd3GOH6w7uscN1B/fY4bqDs1dwjx2uO7hHb4gO7jVuuvSG6OBeI6dLb4gO7jVyuvSG6OBeI6dLb4gO7jVymnpDdAGxFrD0hugCzVjA1BuiC0RrAbIWsPSG6AJsLZCtBYq1gKU3RBeo1gLNWMDUG6ILRGsBS2+ILlCsBSzbIaqAqTdEF7D+iEy9IbpAtRZoxgKm3hBdIFoLkLVAshZga4FsLVCsBSy9IbpAtRaw9IboT6YsvSG6QLQWIGsBS2+ILsDWAtlaoFgLiLWApTdEF2jGAqbeEF0gWguQtUCyFmBrgWwtUKwFLL0hukC1FrD0huhvL1h6Q3SBaC1A1gKW3hBdgK0FsrVAsRYQa4FqLWB9GGLrDcExmHtDqIZbb4gO77VzdYf32rm6w3vtXN3h2TO8187VHd5r5+oO77VzdYf32rm6w3v1hlB4t94QHd5zhHXrDdHhPUdYt94QHd5zhHXrDdHhPUdYt94QHR7IG0J5kLwhOo/XztUd3mvn6g7vtXN1h2fP8F47V3d4r52rO7zXztUd3mvn6g7vtXO1wrv1hujwniOsW2+IDu85wrr1hujwniOsW2+IDu85wrr1hujwniMskjdE5wHyhug8QN4QnQfIG6LzoESrlQfIG6LzAHlDdB4gb4jOA+QN0XmAvCGUB8kbovMMXu/3O+h3IihviE4E1bCuv3cF5Q3RiaC8IToRlDdEJ4LyhuhEUN4QnQjKG6ITQXlDKBGWN0QngvKG6ERQ3hCdCMobohMxHBGUN0QngvKG6ERQ3hCdCMobohNBeUMoEZY3RCeC8oboRFDeEJ0IyhuiEzEcEZQ3RCeC8oboRFDeEJ0IyhuiE0F5Q3xUHkF5Q3wgQXlDfCBBeUN8IGH1YO9IUN4QH0hQ3hAfSHBHbWDeEB9IUN4QH0hQ3hAfSIyHBLYvyYAKXvFcwSueK3jFcwWveK7gFc8VvOK5glc8V/CK5wpe8VzBK54reMVzBa94ruAVzxW84rmCVzxX8IrnCl7xXMErnit4xXMFr4BV8ApYBa94ruAVzxW84rmCVzxX8IrnCl7xXMErnit4xXMFr3iu4BXPFbziuYJXPFfwiucKXvFcwSueK3jFcwWveK7gFc8VvOK5glfAKngFrIJXwCp4BayCV8AqeAWsglfAKngFrIJXwCp4BayCV8AqeAWuglfgKngFroJX4Cp4Ba6CV+AqeAWuglfgKngFroJX4Cp4Ba6CV+AqeAWuglfgKngFroJX4Cp4Ba6CV+AqeAWuglfgKngFroJX4Cp4Ba6CV+AqeAWuglfgKngFroJX4Cp4Ba6CV+AqeAWvglfwKngFr4JX8Cp4Ba+CV/AqeAWvglfwKngFr4JX8Cp4Ba+CV+AqeKndqODNua63Zan3NY57y3vBqVg4DQvnRin0+3giGA+B8SQwHgbjyWA8BYwHbHeOYNtzBNufCWx/JrD9mcD2ZwLbnwlsfyaw/ZkM9+dVQuwlXt9Fj3tlVHkaFk8KYDwRjIfAeBIYD4PxZDCeAsYjYDxg+3MC258ZbH9msP2ZwfZnBtufGWx/ZrD9mcH2Zzbcn1eJai/RzCVysJeI9hJkL5HsJdheIttLFHsJ+9VdXv/SPni5XkVohMjrU/74kVxpA0YiYYTIiIkXPkDk7gvuKpJHiJQRIjJCpI4QOWKd3H1LVh9IhxEicYQIjRBJI0R4hEgeIVJGiMgIkTpC5IAVf/+tT33nI4wQiSNEaIRIGiHCI0TyCJEyQkRGiByw4u+/yasibYDIrfe8j1ZJA348xMBDVPIQlTJEpY1QOeDdvd+iEoeo0BAV8/WS4v77r7LdJfXB8SmHlYYp37+0bulNC/zPL+esP30ou3BXp9zNKff+8vUAHr2Ck1fw5BWcvYJnr+DFK7jXuBm9Bs7oNXKS18hJXiMneY2c5DVyktfISV4jJ5lFzlVArAVejkR5PXHizHsCzVggBWuBaC1A1gIv72h1XTRc054AWwtka4FiLfDqSs5hvTSHuidQrQWasQAHa4FoLfDq1zTTGnEy7QoUa4FXJ7mktTFAyXtHnTlYC1h/RPnllczbtyjLnkC1FmjGAiVYC0RrAbIWSNYCbC2QrQWKtcCBK/n7jimrQLUWeH0lb5ud7AnIyyt5265vCERrAbIWeHUll7Cm7yW0PQG2FsjWAsVaQKwFXl7JbX2TpcSwJ9CMBWqwFojWAmQtkKwF2FogWwsUawE5UGBvJddqLfD6Sl6LDQrtCbSXV/J2rnlDIFoLkLXAyzH5wa/MxtYC2VqgWAuItUC1FrA+DLnxzudRCnzjzbKfbPUYt6cgTHsaEcWE/qcf4fCtN5O8wJNn+OQZnj3DZ8/wxTO8eIavnuGbY3jyHGHJc4QlzxGWPEdY8hxhyXOEJc8RljxHWPIcYQklwn7jSShBc+VBMaF/ZnITimP9U/Ao9vZPwbNn+OwZvniGF8/w1TN8cwzPwTO85wjLniMse46w7DnCsucIy54jLHuOsOw5wrLnCJtRIuzKgxI0Vx6UOLjyoIS2lQclWq08KAFo5UGJKSsPSphYeVB2/pUHZTP/xlPA9ucyeL0/6HXMtwo/3kqEZdjMt8oa3vkZCcERJTii0fbo99tL863ChrcSVTiihkZUAxzR8P3obhtlvlXN8VaiBEfEcEQZjqjAEQkcUYUjamhELcARjd6z73fb5lt1O28lSnBEDEeU4YgKHJHAEVU4ooZGdKtnviHS3Qb7HSniIREeUkY7sbnV5/+tSIKHBHfUFkeX8P0WJMJDSnhIjIcEti9Vn94QC7fLFtcLt8sO1wu3T28IBXfZ4VrBXXa4VnCXHa4VnL2Cu+xwreAuvSEU3Gvc9OkNoeBeI6dPbwgF9xo5fXpDKLjXyOnTG0LBvUZOW28IFRBrAVNvCBVoxgK23hAqEK0FyFrA1BtCBdhaIFsLFGsBU28IFajWAs1YwNYbQgWitYCpN4QKFGsB03aIi4CtN4QKWH9Ett4QKlCtBZqxgK03hApEawGyFkjWAmwtkK0FirWAqTeEClRrAVNvCH0yZeoNoQLRWoCsBUy9IVSArQWytUCxFhBrAVNvCBVoxgK23hAqEK0FyFogWQuwtUC2FijWAqbeECpQrQVMvSH07QVTbwgViNYCZC1g6g2hAmwtkK0FirWAWAtUawHrwxBjb4gs9t4Qi4ZfbwiFd9u5WuHddq5WeLedqxWePcO77Vyt8G47Vyu8287VCu+2c7XCu/WGWOD9ekMovOcI69cbQuE9R1i/3hAK7znC+vWGUHjPEdavN4TCI3lDLDxQ3hDK47ZztcK77Vyt8G47Vys8e4Z327la4d12rlZ4t52rFd5t52qFd9u5eoH36w2h8J4jrF9vCIX3HGH9ekMovOcI69cbQuE9R1i/3hAK7znCQnlDKA+SN4TyIHlDKA+SN4TyoESrlQfJG0J5kLwhlAfJG0J5kLwhlAfJG2LhgfKGUJ7B6/1BB30lwvKGUCKshnX63hWWN4QSYXlDKBGWN4QSYXlDKBGWN4QSYXlDKBGWN8RCBOYNoURY3hBKhOUNoURY3hBKxHBEWN4QSoTlDaFEWN4QSoTlDaFEWN4QCxGYN4QSYXlDKBGWN4QSYXlDKBHDEWF5QygRljeEEmF5QygRljeEEmF5Q/TKIyxviI6E5Q3RkbC8IToSVg/2joTlDdGRsLwhOhLcURuaN0RHwvKG6EhY3hAdifGQsPalwvYVvIuG3wpehXdbX6TwbuuLFN5tfZHCs2d4t/VFCu+2vkjh3dYXKbzb+iKFd1vBu8D7reBVeM8R1m8Fr8J7jrB+K3gV3nOE9VvBq/CeI6zfCl6FR6rgXXigKniVx219kcK7rS9SeLf1RQrPnuHd1hcpvNv6IoV3W1+k8G7rixTebX3RAu+3glfhPUdYvxW8Cu85wvqt4FV4zxHWbwWvwnuOsH4reBXec4SFquBVHqQKXuVBquBVHqQKXuVBiVYrD1IFr/IgVfAqD1IFr/IgVfAqD1IF78IDVcGrPIPX+4M6RyXCquBVIqzXCvW9K6wKXiXCquBVIqwKXiXCquBVIqwKXiXCquBVIqwK3oUIrIJXibAqeJUIq4JXibAqeJWI4YiwKniVCKuCV4mwKniVCKuCV4mwKngXIrAKXiXCquBVIqwKXiXCquBVIoYjwqrgVSKsCl4lwqrgVSKsCl4lwqrg7ZVHWBW8HQmrgrcjYVXwdiS4Sjm0Ct6OhFXB25HgjtrQKng7ElYFb0fCquDtSIyHhLUvCf3+VR9kDvXbpUz5/qV1+0XSAn9eyj//nHvhrk65m1PuGLyCR6/g5BU8eQVnr+DZK3jxCu41bkavgTN6jZzkNXKS18hJXiMneY2c5DVyktfISWaRcxUQa4GXI1FejwE5855AMxZIwVogWguQtcDLO1pdFw3XtCfA1gLZWqBYC7y6knNYL82h7glUa4FmLMDBWiBaC7z6Nc20RpxMuwLFWuDVSS5pPRgtee+oMwdrAeuPKL+8knn7FmXZE6jWAs1YoARrgWgtQNYCyVqArQWytUCxFjhwJX//xGgVqNYCr6/kbbOTPQF5eSVv2/UNgWgtQNYCr67kEtb0vYS2J8DWAtlaoFgLiLXAyyu5rU+XSwx7As1YoAZrgWgtQNYCyVqArQWytUCxFpADBfZWcq3WAq+v5LWErdCeQHt5JW/nmjcEorUAWQu8HJMf/MpsbC2QrQWKtYBYC1RrAevDkBvvNh+lUMneG6KSY2+ISo69ISo59oao5NgbopJjb4hKjr0hKjn2hqjk2BuikmNviEqOvSEqOfaGqOTYG6KSY2+ISo69ISo59oao5NgbopJjb4hKjr0hKjn2hqiE5Q1RCcsbopJjb4hKjr0hKjn2hqjk2BuikmNviEqOvSEqOfaGqOTYG6KSY2+ISo69ISo59oZQeM8R1q83hMJ7jrB+vSEqOfaGUHjPEdavN0Qlx94QlbC8IZQHyRtCeZC8IZQHyRtCeVCi1cqD5A1RCcsbohKWN0QlLG+ISljeEJWwvCEqoXlDVELzhqiE5g1RCc0bohKaN0QlNG+ISmjeEJXQvCEqoXlDVELzhqiE5g1RCc0bohKaN0QlNG+ISmjeEJXQvCEqoXlDVELzhqiE5g1RCc0bohKaN0QlNG+ISmjeEJXQvCEqoXlDVELzhqiE5g1RCc0bohKaN0QlNG+ISnDeEB0JyxuiI2F5Q3QkrB7sHQnLG6IjYXlDdCS4ozY0b4iOhOUN0ZGwvCE6EuMhge1Lzac3xMLtssX1wu2yw/XC7dMbQsFddrhWcJcdrhXcZYdrBWev4C47XCu4S28IBfcaN316Qyi418jp0xtCwb1GTp/eEAruNXL69IZQcK+R09YbQgXEWsDUG0IFmrGArTeECkRrAbIWMPWGUAG2FsjWAsVawNQbQgWqtUAzFrD1hlCBaC1g6g2hAsVawLQd4iJg6w2hAtYfka03hApUa4FmLGDrDaEC0VqArAWStQBbC2RrgWItYOoNoQLVWsDUG0KfTJl6Q6hAtBYgawFTbwgVYGuBbC1QrAXEWsDUG0IFmrGArTeECkRrAbIWSNYCbC2QrQWKtYCpN4QKVGsBU28IfXvB1BtCBaK1AFkLmHpDqABbC2RrgWItINYC1VrA+jDE2BuiVXtviEXDrzeEwrvtXK3wbjtXK7zbztUKz57h3XauVni3nasV3m3naoV327la4d16Qyzwfr0hFN5zhPXrDaHwniOsX28IhfccYf16Qyi85wjr1xtC4ZG8IRYeKG8I5XHbuVrh3XauVni3nasVnj3Du+1crfBuO1crvNvO1QrvtnO1wrvtXL3A+/WGUHjPEdavN4TCe46wfr0hFN5zhPXrDaHwniOsX28IhfccYaG8IZQHyRtCeZC8IZQHyRtCeVCi1cqD5A2hPEjeEMqD5A2hPEjeEMqD5A2x8EB5QyjP4PX+oIO+EmF5QygRVsM6fe8KyxtCibC8IZQIyxtCibC8IZQIyxtCibC8IZQIyxtiIQLzhlAiLG8IJcLyhlAiLG8IJWI4IixvCCXC8oZQIixvCCXC8oZQIixviIUIzBtCibC8IZQIyxtCibC8IZSI4YiwvCGUCMsbQomwvCGUCMsbQomwvCF65RGWN0RHwvKG6EhY3hAdCasHe0fC8oboSFjeEB0J7qgNzRuiI2F5Q3QkLG+IjsR4SFD7Ug7ZvIJXNdxW8HZ4r/VFHd5rfVGH91pf1OHZM7zX+qIO77W+qMN7rS/q8F7rizq81wpehXdbwdvhPUdYtxW8Hd5zhHVbwdvhPUdYtxW8Hd5zhHVbwdvhgSp4lQepgrfzeK0v6vBe64s6vNf6og7PnuG91hd1eK/1RR3ea31Rh/daX9ThvdYXKbzbCt4O7znCuq3g7fCeI6zbCt4O7znCuq3g7fCeI6zbCt4O7znCIlXwdh6gCt7OA1TB23mAKng7D0q0WnmAKng7D1AFb+cBquDtPEAVvJ0HqIJXeZAqeDvP4PV+v86xE0FV8HYiqNcK+3tXUBW8nQiqgrcTQVXwdiKoCt5OBFXB24mgKng7EVQFrxJhVfB2IqgK3k4EVcHbiaAqeDsRwxFBVfB2IqgK3k4EVcHbiaAqeDsRVAWvEmFV8HYiqAreTgRVwduJoCp4OxHDEUFV8HYiqAreTgRVwduJoCp4OxFUBe9H5RFUBe8HElQF7wcSVAXvBxJcpRxYBe8HElQF7wcS3FEbWAXvBxJUBe8HElQF7wcS4yFB7Us1tFtlkkvo27ZY+jzxaR/3xXijTq7UVa7K52+O5QfIdps8d1t97rb21G379VCPb4vP3UbP3bY7cS1sj3sofnfbj1+OVOK3a5N8iaIhbxJsL5HtJYq9hPycxHpbfe623W9121Z6E34wIJI1gaK6O6D94oZjJeKrEl+nhb6T2HkM2rZNM0Ta+1T3SxDeyJNG8hCv11JJu9PFWDgZC6dg4QgWTsXCaVA4HIbiPNqXOWLhHLot70skewm2l8j2EsVeYn/nuh0tnwmt+28nHy3SXhZ5uHXsv+x7sEYcoEEDNNIADR6gkQdolNc1Hm3sWSw1ln/7f3/4rz/94V///Me/LXfof/zvv/zb3//01798+9e//////Pgvy7X/Aw=="},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"item","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"end_gas_left","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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XO/O8+J6d54X17vzvLjeneeFPC/TvLjenecFXe+297x8aLaTzwu63j0rL+h696y8oOvdk/IS0fXuWXlB17tn5QVd756VF3S9e1ZeyPMyzQu63j0rL65353lxvTvPi+vdeV5c707zklzvzvPieneeF9e787y43p3nhTwv07y43p3nxfXuPC+ud+d5cb07z4vr3WlesuvdeV5c787z4np3nhfXu/O8kOdlmhfXu/O8uN6d58X17jwvrnfneXG9O80Lud6d58X17jwvrnfneXG9O88LeV6meXG9O8+L6915XlzvzvPieneeF9e707wU17vzvLjenefF9e48L65353khz8s0L+B6t6bdRyzW0hfmBVzvnpYXcL17Wl7A9e5peQHXu2flBd1f7bS8gOvd0/ICrndPywu43j0tL+R5mebF9e48L65353lxvTvPi+vdeV5c707zgu6vdlpeXO/O8+J6d54X17vzvJDnZZoX17vzvLjenefF9e48L65353lxvTvNC7q/2ml5cb07z4vr3XleXO/O80Kel2leXO/O8+J6d54X17vzvLjenefF9e40L+j+aqflxfXuPC+ud+d5cb07zwt5XqZ5cb07z4vr3XleXO/O8+J6d54X17uzvAx0f7XT8uJ6d54X17vzvLjeneeFwPPS73+6hbYwL+h696y8oOvds/KCrnfPygu63j0rL+h696S8oPurnZYXdL17Vl7Q9e5ZeUHXu2flhTwv07y43p3nxfXuPC+ud+d5cb07z4vr3Wle0P3VTsuL6915XlzvzvPieneeF/K8TPPieneeF9e787y43p3nxfXuPC+ud6d5QfdXOy0vrnfneXG9O8+L6915XsjzMs2L6915XlzvzvPieneeF9e787y43p3mBd1f7bS8uN6d58X17jwvrnfneSHPyzQvrnfneXG9O8+L6915XlzvzvPieneaF3R/tdPy4np3nhfXu/O8gOvdlvM9L6UuzAt5XqZ5Ade7p+UFXO+elhdwvXtaXsD17ml5Ade7Z+UF3V/ttLyA693T8gKud0/Li+vdeV7I8zLNi+vdeV5c787z4np3nhfXu/O8uN6d5gXdX+20vLjenefF9e48L65353khz8s0L65353lxvTvPi+vdeV5c787z4np3mhd0f7XT8uJ6d54X17vzvLjeneeFPC/TvLjenefF9e48L65353lx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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+2de5Bkd1XH78z0PHZ7umd2dp67O7sTSFE8BHqmZxNCESqpSkpKwVLBB8RU2GR3JSFkk80mJIiSKOGhieUfgKBoQAqjhVICJlWioawQQEvKkkdZREUKDYiAAgWUxBLK3E6f6c+cPr/bfe/cc/v2MF01Nd33/u79nXN+r+95/M5vJHriU338b6T9fbz9fyLq/kiZS9r/Gzv7rOf4roYnnSNDQufokNA5NiR0VnKkM6ZtLNr+yZvecQe55k3jxBDQOJlzuwuNlfb3qcf/9j3+tz96Yu7tuknGRtsdJ74fN3AswEmUCb30p5Rw4s9X8H2l/f/Ss2dP3L527Q0nT922duaWc2tnTq9dfeaWG07ezAe/ge+H2/+vOXH99WvnzqyduPnmU2fPXfWqE7dddfW15666+drXnOKjj2Wtk5SnevAzWR+cG8v44I/gwfPa/0+cO3fqVTeeiyV08y1Xnzt74ppza6++9twr1s7ceurs6evPvJovWM9a8907rfmtWWv+3awPfhwPHukm+cTJk2FqP5e10n/N+uD/7YDa5UrGSo9mffB5lezU/nzWSq/J+uB1WR980w7Y/NOslX5uB5V+J2ulTx/P+ODLsj5423h2Nr+XtdKLJ7JX+qKJjJW+OOuDN+2A2nuyVvr2rA/em/XBB3fA5r9lrbQ2mb3S5cmMlR7N+uDzdkDtdVkrvSnrgy/fl/HB1+DBTCjjdVlr/ped1vylrDV/LeuDi/s739P2iafuz1jps7I++MIdUPuKrJXekPXBu3dA7R9lrfRDWR/8cNYHP7cDNr+ftdKnVrNXekk1Y6W3Zn3wD7M++PAO2LxsOmOlb57OXuk7slZ6b9YHH9wBtY9krfTRrA9+LeuD+2rZ2XxWLWOlL91BpSezVnpd1gfflJLaLZvNb7Uf1Nas3Eyqz2lcM4EKWE/8ia1mlfZF+T/S/qu27/PB+Jpo+iO4JnrbKK6JkjOGawJ3K6Bn0ofv41MdsvN99+Omz5gXAT5CfxXfee8IRFjx4fU5U5B3zrxuurXR43J0bKOWSVnaYbz97in8ljbZj/pzdGGts355937VPyr4fhhlAU5aZUZBb/yJpw0ZS/sTntPW8jrKTOC5KfWc/JZ2j+V1oP09/j811Skr78f6smMZNk9d1DzVOHU6fkcVNEi7TYNWuX/ZZKfcGuiq50jXqZOnNy7c3Lw6fkfNoKsOuuT+h1HufNDFMZVjv2vE757wefc6+0ql/W7hYwK8jaH+/Mb0+ibXlQh18AMb4hYdbnNvew7z4feJthzFu/NzXR8/Hr+vpuQ2ruRWRxnOQTUnWY5E292/FfyuBerPTyYXtDxy9T5kUjdoqg9AJvVA/TnK5Or4fTN9yGTGoGlmADJhnWnorpWEbl1/jm15On7fbB8ymTVomh2ATGYD9ecnkwsvjN93oA+ZHDBoOjAAmbDONHTXSkK3rj+/ttxoYf65PmQyZ9A0NwCZsM40dNeGlO6ZktCt689xPtmM33ewD5kcNGg6OACZHAzUn+O608Ka833IZN6gaX4AMmGdaeg+MKR0z5WEbl1/juPyovh9C33IZMGgaWEAMlkI1J+jTFrr5WIfMlk0aFocgExYZxq6Dw4p3QdKQreuP78+uNkal0t9yGTJoGlpADJZCtSfo0xaGGK5D5ksGzQtD0Amy7gm9sF3u9O0frwahbcLkM5I0VnFd9oIV/COPLcJsK1WUN8hF7k80Va6/8jvQ+71r7d8RkeceIvfverz7tZ6eLT9LvEZrRpyO4b687avH1XvlrqOoi3l+++jrJSTMjJfCP2xzig+pmMJzy2r5+ooQx/VqnpOfku7x/W/pf3ds6/109djm42Fq5zmypafYira/ulnXtJzUN7jxonfBn0gUZTveDykZDalZFZHGc7lg5xb9+jeo7sfuqtRx389hWvi35a5IJ5LbxnrlHPyNW3EddMnKHVEio8IMhWanPwDzWq03SfXiyba5738OI78Nmgfj6J851Jtq60rmQ3CNq79UfI7yca8R7cf3fT5C71VlCvK99APnUX7KUNxUrP+9TcY+yJ1xL8fQd1O812TcRGiF40r2W/r34jF+nz7Wi3qjpsI9StP/2SoX9FPOqPk7B3zomMgGecn9TvFYDYceWtS3tJvJhVvbIP/VHLnx2o76U98px6To9H2dozwnVjnkj55Pt3jE7/jAOiaNfiV+99UtPJj0S12qVG8Tz/L+cfqRzlgi3V9gTSORd1jynOtcPSbNulHk/4rfEidFZT5X9UG/PBd8pz0X/r15Vn6n5z423D0bTXp6xDZCR8LkMGWX2EkWXaLAdkdhOxEZvQReMXlxWvXjEFnpOiUD3UlL19OWl2JcvLycVaj7W3Xiyba57z8O9Vouy+4F01F+Feq0XY/WC+airAZ0k/SD01F+DaqqKcfmmi3P+xI06EUNAkdVvwp44u5b0PGEHVHHatAP+kormlfV3xtRdFF+xgzJx3C+4QeYgi2RU094ziGm2llXsQYduS3YcWvHFK8sU9wLHrGr2jfvfxmnWnonh1SuouKF+pFt18fbF7oiF2a8Ty4HzJeVLImf052jo20awvtTl4405Hf1pxyWPG2oniro0wF/HqtpSNR974N+c0609C9UBK6/dqyeYFjzMWGjE2R8REla/LHuICc6m+wDWNdUnDMKmQt968a6ZR70UiHLqc1fyMtDhl2X7+1Bh1SvBGH0tfqGa8X8rWyzjR0Hy4J3Y5t2XRczzdC67nmj34NuRb/PjHSff+wcd+xfVLjgd2gY2g724rijboo9wR7xieHMG9SXHUS3eMloduxLTcd9ZAuPLCgZL0IniUvwK1Yl2/G2OX4uiQf+hpckxlDc+VYt9x3UK/pB5FxT3sJ65rCd7GXEBN42ePTxvYUECe57shvay7T+/Bqijfuw5vCf899eNqmIL9ZZxq6Z4eU7gL8W33R7dcHn7CXOPk9t+wlIuM5JWvy5xRPsZE2zrmI/ZGO/DYsHV/bxGnTp73EM6eEzgMgv5NyYSTRfbAkdPu15RP2Eq84Whmb9N9EAf44PnKqv8E2pL2kgv9y/0PAZe8GLvPCjml9ikX4g71xiI77WFa8cS827SWee7FD62LSHvIkumdKQrcnhvaMxZE5Q2SsY2WEP9okGJt0/0j3/RnjvmP7bKSNYSjCZ+bIr6ljLCneiHlpL/HEvHrc6rwaaeleKQndjm256YjVt8a2yHhOyVr449rI9fsThq0zyo++hiNm3kwba1WEjsC2+MVT53781O0/e+L6a0+eOHftmRt++tRNt5y6+dwIql5QZPJeiJVRXGNI45Jxnx/vLQyhIVZAWrOmozrR2gastyhouF1Bmc+ObOebH75LnpM+wG0CDMUS2XnC5nmDzkjRKR/CZs/tgmmGdhGpIdOGwBK2em3xSBsqXMC2j9Tm4EnQNOUkJ0d+W1BtQvFWU7zVUYauvAknfkei7kMqdTrlPbqLpZsqLbepSbn5EtHJMelM02ba9YfpwD2PD3DitzGi+CFWYhtIGfbfihO/1piawHfWuUd3MXTnZMJt6gtx3WN9yGPMoMcpHX2iPJJSKPLol4US0SnXOI96mYG5rSOEzUdyrs9Kye40X26kxbjsw3oLDPsL8XlZ+suUP00bVUWT1BGSp0Unx5/cJw+jjvIMpQrktiS5NlkATWlTBVp0ctx6pbfbduxWH3QeAZ2kOf7QFcDw6fXRDh+e238ZzlkxaKHZ+Z8rnbLH2/TVom5XBl0MnBsGueUmptMK2x1k2DDn1ZUSy44h18uQp1ybAO0a/wzaHVGLbPfjIN2flk5dRtlRz+Y4kmujuCbP0DXuGeIzB7oZKsE66dIjv3xWyrykzUw8t10z2uHfGp+WO70s7cRtEsPaxzzdwcQKofDGvDH+qOKZfcwaT9rNmSM96yMGr9rVyXHxCoyLfWO2vIpaN9lnrHEp94s6wkS75/VxIXTPM3zcM/13aO3pNS/Ifc4LXlvfktp4BXTqUCZP3Z9zI3H47cDhXlu8RqLtWyA4TzJtu5T5beDwX/anr0EdZRl03oG6vVJIjKg6KYclyEbKXAbZvB5zrNynjrKgrg0aFxJTE2/Jdx6zmITBiMcPqGvesQuhcGGmWLPSaXqFtjj6NjaZGjFCHZGSgXxoQ/FMReDFbzxODkadfjap2rZitKvn+qvjP3SqNuIEHithHXXmiWd0ilmdno4pZmkbmFDypW2A49kTT4RsA9Z27Dr+a3sccXABIaU7isXxTJOdJhaH8V6e84VnmmyPUEgLP+rURIM4eieUtpZ17tFdHN2WbYFr9nyJ6LTiFD3TVAuGZurfh0qI56vA8x838Dz9Z5add5DbVkN4XtsPy2i7qEX2NtUi5DmSIM89HcemSfeVousP4UTGYst362h3jmPryAAv/JM0PxPPyjXiWelv3Boi99kXB+1rkmvUi3od+Z2nzZnYvwDdcNv6JnXE68fXR93bpMk20evbvNFOfzvWKfvNXeBTH2a/sGVXG2Zfw56t3/w0+7VP0Oc1zDZkT3+q4zhuEtdovwiPdtiyp7XbKrRfTNvhlg3Z6bXSM0aI6xTjsJbH3OtOrYfdhnXqCMZEv+uU55gIrVNs137XKa1flEEPs9YuvV2dOgdjcIrQg7TOwTrrkCexNWNwpMwzE8Yv2yGK8p2/nPbKtcaY+Ej0ftcp8C9lNnrw77XP0FEG6/I+4ZVzypS6Hn8uxDxzUfs794vST/4C434EPvip4Dv9cE7HVLfs6kd93t2yfx+DHCqoi7ytof68Y4j08dpS1zHIW77/6FinrJSTMtKeQn88j0m8NOnXz9XVc3WUYdz3UfWc/JZ2j+V3MfrcC7D2eh4ndyTAD1N9SZkkvd2KL/PWrbRcaqp+a19LSGfy3N8QWlup23FNFZo806lpHKRtwSGdTe4Tl3j2z1CafB6BY9nuJKUrbSBX+uPZzR/GNNBaF7TSKUsZpkov25EtSXSPDyndRRzb5kH3oZLQzWPXaXeTY9epu94CHLgPZeX//vb3aTzz0XZB6obcJxjaF7Vs0Pxa4IeHetiLyrZ3gHqwZQelbjynrhXl0xLatU+LejD1Za0H0/fEGPsifErybto65XoN8iQG5LFvUuaeBN2whnLsa5Pqmvc+/FA+jAroFJ1v0p+mJnG2HsfUSaXM23rYDzVmF5mvgD/h6wj4c9qH2qRuLfzNqvqpW7+zh33Bqx0cZdDqd6uK1yVDBlLm3Zir34N1Q/ol15UPGvcj8MFPxfgeP3PMiW+t3+eNLc+DHCqoi7w9CfXnbV84T71b6joPdMj3D8C+IOWkjLTnWvt/PEbFBkD69XNT6rk6ytCus6aek9+0z9yHPvfBguwLRwP8MLZB24yo00n50DriaVcOrSOkXR9RH8qpwDVWaPe0ddYU7bQrCJ2WvUSwCm09OmaC+NLTL0XfkPChdQZiy4kojJGlzCcS1p7Q/qJlYGntZy1rzFySr2bYYtasmC3m1CSWdprLWhhHxo7GcDXwI2Ue6YHhppQcdCxC/E7G4Mp/L9+LheGEFuJnKfOFAWI4rxxxxNbC67whAynzKNbTLxsYjbaj7+aA4Zz8OOuO+LBBbCL96pjBm8ZZefHG+uXdUtca6JDv3wGGk3JSRtpT6I/HqOB50q+fm1LP1VGGfr9j6jn5Le0ey++r6HPfLQjDrQb4oS1hFd+FJs9YC73nTsc20t6ocUEdz0mZ7yfMZyE8asVcedo1QjFXFdDJmEi5ZsUHlxmP9utn5H5E3baMsx32fRo6lntYbKCe+6lp29R45QDolDIr7UESwmM69l5kTjym44o892gSK2v+uM9ZyhxL4M+xHZre+gLnatrUKAMpc36lI6+ntL9TP6NOd9y4H4EPfojHGDflNV86YtyGhfMnDd5oJ80bj1XUu4m55b9836x0ymq7t7QnbTCyhpB+/ZzOG8AYF+KokP2HeuDT0eekT3n7LGsBfrgG6rXUM77A8qNqOwrXEI3HGOcrZS5OmM+4n5aYRuePGvSayHwK9CdbsdYPGVhlmHPEDHMsM21M8gzjmw8YPNYNHj11slDOkRr+W3u5nWjaTGsfe2kPPKbtYyLzJPsYeebYmVLXvNtG00765L+Ov/a2Xer4b6ttpMzJHm2j18UtjI13av96FG23/Vq2TSccuZnE/6zB/yt7YGmvvEbeWJptTdsmZSBlbgSuOQusrPPSx/fvNO5H4IMfYmniKS+/vGNsfYP+TelXqwZvOkY9L95Yv7xb2wwr+H4HsLS2NUp7Cv21qNNWpF8/V1fP1aNu+65lQ5TfjIu5FX3uTmDpIvaEaH6IpaVMEccNUu8XmtLYNmn7kDJv7oGlrdxkFt709LuE8CZ1NLlm5SZjfH+Zc5PR3ik4k/53wZlz4Ee3LXNecu8j40b1nkrpOzyelT70vOelFfVuLRP22d/DuP9spZuv3ZJ7oIx6UFJumyQ9iLp1lB/djaJ9+NRnRU5S5v09cKDXfk1v/UT785cNGUiZD2Fs3g+cpzF/fP9h434EPvipKFnK/92GA8lbWXDgRxNwoLRnWhw4q57bCQ78C/S5h4EDPePkKwF+mL9I40BiJ/oitf0upr0seU2YS8ra32fZsYrw7wjtdSXPetStc/aLnYgnvDHgiuJD500nlpiIbExGfPFIwtpTNZ7VOeLLclbTFzCWL5ro0OeVqyVtblvuVfbS6Rz53XYGjfCmMR39EMx5MEjsmZbu2ZLQPRV55P9oHrf0fkseBwx6PH1cIXnQFuKZdykUA8G8S1Lmuz3s1iH50m6dlC+SemhdXSuDv4f9RGjyxEyhvkGMMaPkWUbZEWNQD9ZYiL6kIs6spr4qtGu/CmMeqGsMOpbPssuVTXb1yPbNyTXaOqjD5K27Tap3V1Cvpok5tYrYz1lRsmOdlJO2K0TquTe2Eyi09tOMd/hawDuEL88zx+bVu3V8BmmirL1sPaRBZM18ifJ/0lEmC+rdUpeF1aStdT77Csq8BG395IS2Jq9PwTMvHu/w7aTHFJ5vTbcpbWzPaPO72/OtHTRkIGUaaP+N9nfqucSBlxr3I/DBTwXf9/Kt7Yw31i/vlrqsfGuXjHfKSjkpI+2ZNt/avHpuJ/nWLkCfuxRzjqd+eSTAD21bUsY6n5n7F6x9p4PUBZnHjHs4LCxo7V/w9KmHYjVp36VfTGjy0ktow2R91NdyHLvbzn/lHpkXYwy8wVire531Z+V6rfjIzMyjQuwk/6XMFT3WVS/87CgDM8/IQUMGUublaN+rsW7KGsx19SbjfgQ++OG6yhwzuy3PCHl7EurPe109T707Kc/IjVhXpZyUkfZca/8fRJ6R0+hzN2Fd9dT1Q3lGuA5JGcbiFLleypzKOrVPSNt86Uu5PWE+S7NH1TNfRyiOy8rxRzuMhREmIRuh3VNf6bXfJ5TvJckXyTMc3oBxsQZfmCfuCWE24h7LRmvlB/TExaH8gBy/es+Go+8h0c7Jdrb6rRXnVRZcXgC2bXDekTriPv92rAWePiOOudCcKmU+OdEp+07Q53VOibXvPK723hLK5nbI5j3QDaxzA62zjIc1J+ee78f8bDratja53keoI1IykM9R8Oula3nyK2eY6/MDtA+lgP1hZvyb/CbOsWxQOt+rt885tCbT55y0Tk+CdmudHjQW07p8vzn5HPHZBvPERagjUvxEik5P3wXXnH5oKiDPr2veBuKCKMf3Wth7TskshL09x0pIF2Ode3QXR7cVe8Y1u6i9cf3Qaa2hXuOSeJ4+3y+WEM9fAjz/JcPWP2w5Tb31/9AZOVlyqnpiolBOVca5le0ccEvvcpRTwxOLED/LOBQ+rNypj/XwS3n5z7z11TS5U38AW6gMFOoTzC8wY9yPwAc/FeO7ox63lzsV3+sTnbJSTspkzZ1aU8/tJHdqBevfDOzvnj6F1QA/1FeljBXvIeVDNnnPvc8hmzxjVZhrS65Z+UYt29kgc/Aw9tfa25E3Tf3q8fQNcT9C2c9usnKpFpGfTN6t6+cYWiqx7DiGeuVR02dhlaHd9Zld3u2ufde6fs4/CyWWHdud+ym5R7LIvBZ6D+dIFD5XY8ng6/ltunudq0Fe15HDRMf50r5HncVTjwr5lKhHJfmUOFbLll+7FnXve/L0FdFW008M/E8k9B++S56z9m0IX7T1eup8UwH+qO9ImZck8Oe5F8Fb56uAV9ptLL33pcDfV0Cnk35JW9Z1xv0IfPBTUbKU/7stxp+8raH+vHW+NDH+10Lnk3JSRsfq9xvjr32iO4nxvwp97jqsrUXG+Fv5K3S+6aJjmbSd2FrvdQwP2/RswnxGXwHjovQa770mhjAYdVUdZxaKXfriLot/KXvuYsuGLd8ZuyPPMHZnyuCxYvDoeRaotkPKb457y0/lRNMmbVEar1jnk/5mDzwWOhOIY0f4WjV45thZVde826ZXDir2oVV/mppcy5LaRsq8o0fb6HVRZM62Eb5YVtvMNP9eeY+T+J80+H9XDyztFbNVtP/kgCEDKfNe4Jr7gJWlvZgD6wHjfgQ++OG8Rdy55sS39l/kjaWfBDlUUBd5ezLqzxtL6z1DUteTIG/5fj+wtJSTMtKeQn88hgWDk379nPax1FGGOP889Zz288Tyex/63APA0k7+ym26iOaHWFrKUD/yxF56nrT29eizTizbh5T5SA8sbcVdWnjTy8eZhDepo8k1K+5yFbQPW9wlfXXEmcKPblvG81NfYH7mgyhr+S+0jpr3vBTKg2LFDX0a437fZDdfe3pQNto99SDq1lF+dDe8cXAaHeXfe+BAJ/tf01s/Yc5ezleWLvAVjM2vAufpuMj4/mPG/Qh88EMcSB1gzYnvQeFA8lYWHPi9BBwo7ZkWB06q53aCA/8bfe6xAeFArdNaOJDYydr3UdRZalnxh6xDtE1adqwi/DtCW0XJM5QXux/sRDxRtD/esn+HMPs8ntvyCbfpDvm7rT2ebwcm1Gs9c+bTJ+CJnfSZt/Kb2EnnN3ekaVsuPJmnxxVNbIOVhDawsCH90cKfPMsYsCLj9YUWC3cfS+DPcc5qeo9F5gyM/2YMGUiZ8yc78npK+zv1DOYyOm7cj8AHP5zXqHN55caI3+2Uf76Fb5gHvhJ1n3ce138I9eeNb/R5P1IXc9vL983JTlkpJ2WkPXkmyWL7O+nXz+n85nWUWcRzobMSGJf0dPS541ifPOfixQA/4+BHynAunnGkSa8PQgvrpM7MMtb53BcnzGfct0u8Y8UseWK1kE5OrCbXGKum+Y5/PwKap31obu3NrUbbP0lz3TRocoqla9E0nYIm5iv3srd47y2aAT95vdcag9NKZvWo+8zbqWiwZ7YMK93xbxlLQi/noGqJ6LTmRa/+zfmNeOtKrI1O43ZjBG2hMTPjkqTML9Q6ZU/AVk39X/5Pq2ve9l7OiaSZ9l7hjfO009rR8G439hWLX/btV/bQ5fSYmFRyit8p7VjUeuKEvTY4f4rsdJ4V6utne8huNiA79js9x3jalTifkM5I0SkfxnN7zbtpbeJFYPC05ygW4XOrRtuxTi+aCshPs76T/DRedo60Ngj6zGVscD6jvVX+S98YxTVpG9pfaTuTa0Ib1xmv+SytLIrox478mrhd+8XZfkXhyhlFk7btpqW7XhK6/dqyeaHjOrgR07w/6s7/Y/HnZPPYSLsW057oNXc68tug/Vl4G1e81aPtNmrhd5B77dPSPVsSuv3asnlB/O5FH962xqbIeFHJmvxxL21O9TfYhjENsp5z763cfwj26j+DTu6ZD5DtLnXwUzTecuS3NWfoHEtWfmopw7MwBhn7lpbuhZLQ7diWTUessjVniIy1b5n+gil1LR67D092318w7ju2zwbjYyLUwU/R+p0jvyZWt/Kna13LG/OGcrolYfUkuqdKQrdjW2566rAytnXsmOYvrlNisx7BuvyPRpxTlB99Da7JjC1/375OvXv6fS7vbs0Zej+1pScztkv49fQvhPRk1pmG7iLs6P3Q7a3fe/nmtX4/rWRN/rxsDGnzZ9DWXvWhyTVPdvy+CcWbzsXJ2Frq9xNO/I5E4bzFrDMN3bWS0O3Xlk/o9+M+vG2NTfooowB/HB851d9gG1K/r+D/ls9vqlPu+8ARe+t5Lu9uWP5la13U+64cYy4S10XWmYbuovJR96LbsS2bnjENej2vGbKOP9ShOb8cmOq+P2Hc947NS+MrLaDNXGPzLMyr91QS81K/H+Tez7R0HywJ3Y5tuVkEVhcZ63hF6nJ6/Mdj98kYu57rcpqxW8CZTBtp40GK0CnT6jzsu079az1t7nrGZXieoZQmTnvYdUPqSlGU7xozrmQ2rWTGuB7iMCf9JlF3Y517dBdHN31tjD22zlAaNJ06XtqRps2069o4aPKKUXXktzGi+CG2YxtIGcsW4dEv9Jgax3fWuUd3MXTnZHva0Bfiusf6kMeYQc/YAOTBWFbrrHK9L7EMdGp7oqf9ijaeEOYfybk+y0fkZatNi53Zh+U5rrd6/1CZ+kvVn6bUMZ8WnRx/cp/r8qijPPXcJb8ZBy/XJgugqapokjpC8rTo5Lh1imls0Tmags5F0Ema44+VRydu/9cVYAdhnInsj9K0cE17RrVT9tfa9DEvHG07B9Q1T7sn+dA000c8qLMbhSZdv2V3LKPsqG/RZqexDu1FnMO8bEFJdlTuZ7T8JoP024Tm/7LJzsJD3OM4imvyDH16nrEJVdBt2S1GcG002u7j47NS5g/gG/7AVId/a3xatvqytBPjkYe1j3n6sYgV6gEZ5I3xRxXP7GPWeNJ24Rzp2bZ/Xt6t93tzXDyAcfFz+2x5FbVuss9Y41Lvi/e0r1OOWmaUp1wr4mzMpLWn17yg8yR57jFJamP6+60cyF66P+dG4vBPAId77aUYibrzWOv5nNj8P/Z3yv6dP30N6ijsJ3+PuovMZajj89l/3gLZfBpzrPY1099agM+9L1xITE3a9F70XhiMeFz7JAYd58j8IgWcL9iKdXDKF9jyt9APKnVESgbyWQa/XvZwT37jfhiPvWnFj44BLsK/bfki5DfXXysXntwvCr9XFZ06N1Yd12gb0H5X2gY4nj3xRMg2YO17rOCatsdZti/vGJ80sSvEGE7zYzNtjE8R/jNHfhvEBVGO77Xw44ySGfFjEXsrR6LufQc67/ge3cXSbdkWqormstBZ4D6aRihuehb6fVnw/BXA8/Nt+mpRd95qzq0hu05ReJ52CAvPW7GwZbNd1Ax+ipLnSII893QcmybdV4quP4QTmSNRvtP+quMfqpG9N88zfig0PxPPyjXOMTrHKOcg9sVB+5q49sk1y6/P/pGnzZnYvwDdcNv6VkV7PHefe5s02SZ6fasb7bSC9e35WN+G1ac+zH5hy642zL6GPVu/+Wn2a5+gz2uYbcie/lTHcdwkrtF+kWnIQMqcaLdVKH+ztsPNGbLTa6VnjBDXKc6Zp0uoh/3Nvk7Z6zKsU55jIrROsV37Xae0flEGPcxauxjbItfkGcbgFKEHaZ1D1ynXiK11/E78+aWE8ct2iKJ85y+ns6paY0x8JDLGRGbMPyll7ujBv5Nfp+kog21nWklbzxkykDJ3YZ55Y/s7z2ukn/xtxv0IfPAT8sMdduI7frfT2bYt+7c+3/eIwRvPMc87hmhVvVvqWoW85ftb93XKSjkpo8/kjecxOW+M9OvnKuq5OsrwfLMj6jn5Le0ey+830OfehrXXK358JOo+d037Tusok6S3W/Fl3vsGtFzkt6Uz0SfLtUro9NQBpT6hQ8uJslsETUXkfZB3a1twSGdjjgSh07N/6pwZNSWnkO1On2Wvcyd65awklo5QR6T4kM9uyLeqdUErb6mUYU7iQdqM0tI9NaR0F3W2ZN50z5eE7ng8t6eNbXa3trl0m+76UeBA6S/78IyslftxjbHWck2vrfE7qDtyH2Fo39ScwdMngS/m2kSE7Ell21tAPdmyk1J3rqprRfm8hHbt86KeTH1a68n0TbFfFOFzknfrc+uJs0R31joQsdfnE3RHnv3LvrasrsU8rzjyHDozeAV0iE647E9Tkzhcj2PqrFLmyz3sixrTi8xpIxO+DoG/Q4786fOsJ1T91L2/3sP+4NUOjjJo9bvD4JXzMmUgZb6FufrbWFekX3LdGd3ffT8CH/wQe65ApqtOfGv9P2/seQxyqKAu8raG+vO2PxxT75a6jkHeW2X2d8pKOSkj7Sn0x2NUbASkXz+3pJ6rowztPtpuoe0ksfz+B31O+pS3fnckwA9j47RNiTqflA/Fa3juqw7FaxCnyDXqq8xnIbTLfWIWT1uoPp9+Ucmzjmu0U4yBZrmmYyqIL4ve2651CmLLiSiMkaXMUptua+0J7T86DT+U9sOWNaYuyZczbDFtVkxXDc8QSzvNZS2MswRZsZ8tgh8p87SEfsZ3yXM6VqEWddbyJfDn5ZuxMJzQsgw6pcyzE/jzxnBOMthmLxcMVzdkIGU2EVN1gYHRaJu8PAcM5+TnWXfEhw1iE+lXqwZvGmflxRvrl3dLXUchb/l+GTCclJMy0p5CfzxGBc+Tfv3cknqujjL0C66q5+S3tHsrthB97vKCMNzhAD+Mq6LuIzR5xmJUFE069pH2SI0LKvgvZV6UMJ+F8KgVk+Vp1wjFZK2ATrlm4VHihDLj0X79kIzx0G3LONxh38ehY72HxQbqud+a+pnGK5OgU8pc2wOPaV1PZE48puOOPPdwEitr/rhvQMqc6YHHvHKSe+sLnKtpU5tQ1+PPOayNtwJv6Xjl+P5dxv0IfPDDtYb7CrzmS0eM27Bw/rLBG+2keeOxFfVuqYu2cPn+euAxbfeW9qR/QdYQ0q+f03kFGANDHBXyI1APfA363F3AY54+zcUAP8RAei31ttPo9cGy00h7aTzGGE0pc08PPKbtG9xvwPXcc00M7TcgVtH7DUJ7hmZ3Qfx/CKsMW6wzbUzyDGPKJg0eKwaPnjqZ1n/kN/2v1l5vJ5o209rH/jilfUxknmQfI88cO0vqmnfbaNqXlBzYh5b8aTLjw622kTJ/3qNt9LooMmfbaP96FHXbfjX/TjhyM4n/CYP/v+yBpb3yHnljabY1bZuUgZT5a+Cah3rYNj+V0bbJ2Asvv7xj7H2D/k3pV4cN3nQMe168sX55t7YZVvD9H4Clta1R2lPoj8ewYHDSr59bUs/Vo277rmVDlN+Mi/k4+tyngKUreE/eY2IlwA+xtJShfuSJvfQ8mca2SduHlHmkT9smc5dZeNPT7xLCm9TR9FkitG3SLjtsucusfQJV/Ndty5yY3BvJuFG951L6Ds+dpG6W97x0UL1by4R99r8w7s+vdvO1W3ITlFEPSsp9k6QHUbeO8qO7UbQPX8aFpaP8oAcO9NrP6a2f0JdNu4WlC4xVO/Iab39nLBb3Sc4b9yPwwQ9xIHWA3YYDyVtZcODBaqesxnPSnmlx4IR6bic4cB/6nPSponGgzt1n4UBiJ/oitf2uTHlPiD+s/X+WHasI/47QVlHyrOMabZD9YCfiCW8MeFDxIf2GddJ3ZWEy4ountekOxSnqZ3UO+bKc5fRsjOW7pjv0eZ0LTt0lQh38sM9xL7OXTufI77YzaoQ3jenqKMPzIQaJPX3ybDSPW/qzJQ/rvFxPX1FIHrQpeI2JpFgC5jeSMpcmzD1J8qW+lpSXkfpc2XIwUv8pIM4jsW9wDawpeZZRdtwPQX2ScTpCe9niz+hPYo6GQfrwiNEmSiw7xhtwHOl8HdqGmLcOtKTevazkSZqYu8pz36fWtaV+1kk5kQ8+K2U+Azx1ErayGbxD+Ko6yrqu3i11JZ0n423b0bm+dCysHid5y2RGvZs26UjJSdpa542voMy70NZnEtqavJ7FM/dC93HSBwq31+k2pb3u1Qm4ZTfZ66YNGUiZ16L9fwX2OOlnxIH3GPcj8MHPnr1ucPa6uxPsddKeae11dfXcTux1v4o+dw/mHE/9ciXAD21EUsY6B5n7AKz9m4PUBZljmXshLCxo7QPw9E2H9gHQTsp1WGjy0ktoC2R91NdyHLsNa/8J19rWeYDGWt3rTD2dK8bR327u9ZT6rb2e9/VYV3fLXs9pQwZS5k/Qvu/HuilrMNfVB437Efjgh+vq3l7PnfHG+uXdSXs9/wrrqt6zKe2Zdq/nonpuJ3s9P4g+9yDWVU9d/3CAH87zUoa5DYtcL2VOZZ3at6JtvvRJfCxhPiNGIO9WPJTnfopQPJSVS492GAsjUIcS2gcZ/1yPtudklmtJPj3mgfs0xsX18Cl54p4QZiPusWy0Vp49T1xcV3QS5wqdeu+Do+8h0c5JGVr91oqXKgsuLwDbNjjv0C//KNYCzzMxOOZCc+pWfoxap+xXQJ/TmGxY+7fjur9WQtl8bLpT9hvQDfTcQH2uKF00pM/lkdtyz/djfjYdbVubafdgHAa/XrqWJ79yVriOP9P4gu3q6SMN7RkmzrFsUPSbCZ1libuy1mn6Nqx1etBYzNrj3U9uO0d81opNYuyE1BEpfiJFp6fvgmtOPzQVkIts3ZHfbeeIRTm+18LeVSWzEPb2HCshXYx17tFdHN1W7BnX7KL2mPVDp5Uj22tcEs/TXvFM/5jR1Hj+buD59fb3Yc4N6q3/636clHth2HKTFqWfybst/cw6U8BJToWfYyd8WOfYXd7uNLv9HLu6IQMp82OYi17Y/k59gvv0rzDuR+CDH97fO8duZ7yxfnl30jl2L5vulNV53aU9B3mO3U+iz12B9XkQ59hRX5UyVryHlA/tIfbEWr3OjeX+8Cx5Oz3tGSHbGe0ZVq4xL4zTrx5P3xD3I5T9DCQrJ6ln39Rxobp+jqEDJZYddb1e+cjq6loZ2l3PCUXNSfJua04aV/Iso+zY7tyXyL2GReaH0HshyYPO1XLA4OvXEzBtNbLPcX8dcoHoOF/a96izeOpRIZ8S9agkn9JeXr2tj5lXLykG/ncS+g/fJc9Z+zaEL9p6PXW+xQB/1HekzLt66HxeexG8db5QjL+l974X+Ps+6HQ6Z0F8/wHjfgQ++GHfp79st8X4k7eyxPjfD52vV6z+IHJyvA997gGsrUXG+As/Vow/5+IiY5m0ndha73UMD9v0IwnzGX0FjIvSa7z3mhjCYNRVdZxZKHbpmdDJdkP8C7GKjnUpw152y4Yt3xm7I88wdmfR4HHZ4PGH6CzXTdqiNF6xznL9px54LHSWK/GYPsuVPHPsHFLXvNtG067z+Fv5+L33W9NOGWobKfOlHm0TOveIbSN8sSxtZtY5vE44cjOJ/yWD/6/3wNJeMVtF+08mDRlImW8B13wbWFnai/P8aK37fgQ++CFOYIzdbjuHl7ytof68sXSqc3hrnbJSTspIe6Y9h1f7WOook/ocXvQ56VPee92OBPghlpYy1I88sZf2LVj7emg7Ctk+pMz+tix77eshVrXwppePMwlvUkeTa1bcJeelYYu7pH2CuSuEH922jOenvsA8x5SB5b8YVB4UK27oKPZI/Eytm689PSgb7Z56EHXrKD+6G944OI2O8uyEedPR/tf01k94JinnK0sX2MTYvAA4T8dFxvcvN+5H4IMf4kDqALsNB5K3NdQ/SBx4WQIO3JqT2//7xYFL6rmd4MDnos9dPiAcqHVaCwcSO1n7PoqKo8mKP7g2yX/LjlWEf0do12cJ1qPucxj7xU7EE0X74y37dwiz1/GclHlZwtoT2uP5KDChxiS0jzMeyTMGIGQfp51I6x6ONLXW/1nIqxJ1x3JUUOZUQhuMqOu0p4yDP+FrFvw55Udo5bOdC/DHmAop88oe+MYpL/iGowy25RwXfFMzZCBlbsRacxb4RWRCPepO434EPvghvmFu6QUnvh19XQ0r1mLR4G0QOUxpu5TvdwDf6PVF5wiMi863v5N+/dyseo7r0jyeC8WFSrvH8rsVfe5OrE+ec/F8gJ9x8DOP70KT55pZUzTpuF7LZ8y5VZ6TMm/uYeeSdU/uh9ZEz/MQQmsiz8TS62TV4Dv+fWV7wfl/o4DldK5XAgA=","debug_symbols":"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4jSnWZyzze3iNKdbnOZ0i9OcbvFA3CxOc7rFaU63OM3pFqc53eI0p1l8oTnd4jSnW5zmdIvTnG7xQNwsTnO6xWlOtzjN6RanOd3iNKdZfKU53eI0p1uc5nSL05xu8UDcLE5zusVpTrc4zekWpznd4jSnWXxjHk8V39b9sds6t7yZxr3egbfVm0nc680c7vVmCvd6M4N7vZnAnd5l4D0frzfv+Hi96UuvN33p9Q68rd70pdebvvR605deb/rS601f5r7DMwzloCvREC8UplucxnSLU5lucTrTLR6Im8VpTbc4tekWpzfd4hSnW5zmNItXmjNZvKwH3Vha4jSnW5zmdIvTnG7xQNwsTnO6xWnO502HbXGa0z2P05xucZrTLD7SnG5xmtMtTnO6xWlOt3ggbhanOd3iNKdbnOZ0i9OcbnGa0yweNKdbnOZ0i9OcbnGa0y0eiJvFaU63OM3pFqc53eI0p1uc5jSLTzSnW5zmdIvTnG5xmtMtHoibxWlOtzjN6RanOd3iNKdbnOY0i880p1uc5nSL05xucZrTLR6Im8VpTrc4zekWpznd4jSnW5zmNIsvNKdbnOZ0i9OcbnHm8VTxtUxfHruWreXNNJ7rfax4nZaWN7O415tJ3Oq9MqN4vZlQvN7siXu9A2+rN/O315v52+vN/O31Zv72erMPbvXe2AX3etOXXm/60utNX+Z6H4tY19b+9xZ4W73pS683fen1pi+93vSl15u+dHrXgb70etOXXm/60utNX3q9A2+rN33p9aYvvd70pdebvvR605dW70Jfer3pS683fen1pi+93oG31Zu+9HrTl15v+tLrTV96velLq3elL73e9KXXm770etOXXu/A2+pNX3q96UuvN33p9aYvvd70pdV7pC+93vSl15u+9HrTl17vwNvqTe94vekdrze94/Wmd6zeQe94vW85D749dP+c7nFZSsslcGm63PL1flyH2F3WUlsut3xd/g6XW75+nrtMt3yd+w6XW+6/fYfLLffJvsPlnvPLuUvg0nS55b8/+A6XW+6bfYcL827bhXm37cK823S55wnu3+HCvNt2Yd5tuzDvtl0Cl6YL827bhXm37cK823Zh3m27MO82Xe55evR3uNxz3l224eFy8pbt34a8fc11aSLeczhORrzpO9+5iAGijnjPGT0Z8Z4DfTLiPaf/ZMR7pkIy4j27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"},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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sm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6Usm6U3uRG1cXlXL4vz8pvNGOhp9PF+tXKynZuJvbUzC3I1lLO3/gyXMr7+Oqzbi19fKW42lq6vYfUy9qFe7Vnp59av0m6evzm2Qtab2tOK2Xju3iToPX4R1ovrbSNv743CVp/oryw5ZUtb2x5Z8s3tnyw5Ttavi1seZbaxlLbWGobS21jqW0stY2ltrHUNpbaYKkNltpgqQ2W2mCpDZbaYKkNltpgqQ2W2s5S21lqO0ttZ6ntLLWdpbaz1HaW2s5S21FqbVnY8oUtX9nywpZXtryx5Z0t39jywZZnqS0stYWltrDUFpbawlJbWGoLS21hqS0stYWltrLUVpbaylJbWWorS21lqa0stZWltrLUVpZaYakVllphqRWWWmGpFZZaYakVllphqRWWWmWpVZZaZalVllplqVWWWmWpVZZaZalVllpjqTWWWmOpNZZaY6k1llpjqTWWWmOpNZZaZ6ll3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shj3Shn3Shn3Shn3Shn3ShflC1vbHlnyze2fLDlWWpZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8pZN8q33Sjz88rRXr99iVJ7OZ0tonK5hG0tVrWIcq58vfl0cw2rNVnbt+ZtcDrivFU1ujw//RR2W6WaNWzJFLZmCiuZwmqmsJYprGcK2zKFTTVU9Dxh27bW6st6kcd/ChiElWW5hL1q32OrfYu2tu+1jsKqnE+ryyhsO39wQ8T1BzdcwtZMYSVTWM0U1jKF9Uxh23cO2+ol7Kj90nVtv3S7fIZKDV3bj2O33w/dflmO3X45dvv12O3LsdvXm9s/fxLW489V41n7p0sYfwnnL9H4SwR/iY5foi78JQp/icpfQvhL8HRXnu7K0115uitPd+XpFp5u4ekWnm7h6RaebuHpFp5u4ekWnm7h6VaebuXpVp5u5elWnm7l6VaebuXpVp5u5ek2nm7j6TaebuPpNp5u4+k2nm7j6TaebuPpdp5u5+l2nm7n6Xaebufpdp5u5+l2nm7n6W483Y2nu/F0N57uxtPdeLobT3fj6W483Y2nO3i6g6c7eLqDpzt4uoOnO3i6g6c7eLqDp7vzdHee7s7T3Xm6O0935+nuPN2dp7vzdHec7lgW/hKFv0TlLyH8JZS/hPGXcP4Sjb9E8Jfg6S483YWnu/B0F55u3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lUL3lWL21010/P2O+vDRSB/5fa7uN2aO1DY2/29I4UtmcLWTGElU1jLFNYzhW2ZwmYaKnqioaLfrg37ct7t5hb7DlszhZVMYTVTWMsU1jOFbZnCRqawPVHYkmmouP25iSOFveVz7aysP7s0uYpZZOOsSl2/KSpig8Zdra/fbm221fgtn5hnun5bLHzUeJU1pdbrP83Nxlvra+MtpDxv/PGrf7/+7e3rH9+9+fj4/3z5zd/f//Tp7Yf3py8//efXp995PPtf"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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"},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"}},"bytecode":"H4sIAAAAAAAC/62UTY7TQBCFy06cTIhjO07scRIj8WOLBWvYcgPugARCSAiENCuWHIFjcamhX1VXXn6kkUaaltouV7+vq7ra3YNMRG5CF3kusaXBI4XMwitB/yBu2aAkhSTuGjGo1BhlMnkVHs9Gnyp9hwHlSvim+szeqg0r9NkgCdBphpkR2oYGpCcAFqOnNxd1oi3wMA2wm4EjYcKPSMPE8yhejqk5ZUlsaZqFmYr+pNvRXFEIcqI50Tyid3Q7ulIUghXRFdFVRF/Q7WihKAQF0YJoEdFvdDtaKgpBSbQkWkb0B92OVopCUBGtiFb2vkaKxyP5k0cJa/pEt6NrRSFYE10TXUf0O92O1opCUBOtidbXidbHRB9AQrTfdDu6URSCDdEN0U1Ev9Dt6FZRCLZEt0S3Ef1Mt6ONohA0RBuiDd4vcbTueDArBYWn0Y8f1DL6EQ0zToWt1VDteahbgxszfQS/4C1FOx7w/UzNfdQf4gXSJyrs4ULXjH/Zly8XTD+6rGNgG0jNiUGPsMMbp/PrSVoXCb9P/B8c9Eo7bZhypjeq9WsF4MwUGesLb3esb8v6ducXX/MmjVPjq2WVdtTEgu3ikqwyf2Bp5rFN4s5AdtAaoYydZdbZxpzlfh8aVKY42FZk9xcNQU2B2HvOcRJaelNgU/r0OJ1u5cWnHD/351w7V7OJq+h1kX9hcZGjF7AdY1UlfQ2z+4f+Hypm31MSBwAA","debug_symbols":"7dvbahpRFMbxd5lrKfuwDnv7KqUUk5giiIZoCkX67h0bxwMO9SL8o1avEnWx5tsLfuwElqvmafzw9uP7ZPY8XzTDr6tmOn8cLSfzWftq1YQvMfx9d/Eymq3fWCxHr8tmGAbNePbU/vw9aJ4n03EztPbXo7Kquims7tvSGHNPreRkm2LJWXfVyXqqTbRuqk38sPrbYJ07fiB3DDltKmNQ+eTk6SMTr3EXXE8EjylIV50snAjuVn1T7S6hJ3hmgr83F7K5ks2NbO5k80I2r2DzFMjmkWyeyOak0EQKTaTQRApNpNBECk2k0EwKzaTQTArNpNBMCs2k0EwKzaTQTArNpFAhhQopVEihQgoVUqiQQoUUKqRQIYUKKVRJoUoKVVKokkKVFKqkUCWFKilUSaFKCjVSqJFCjRRqpFAjhRop1EihRgo1UqiRQp0U6qRQJ4U6KdRJoU4KdVKok0KdFOqk0EIKLaTQQgotpNBCCi2k0EIKLaTQQgotpNBKCq2k0EoKraTQSgqtpNBKCq2k0EoKraTQGALaPaLdE9od3VoIgnZH9xYCurgQ0M2FgK4uBNRqRK1G1GpErbIbRuyKEbtj1L9kVLarZqXqv58QPW4f4fuPsNJTrVq6XTC1lHbVvZtjKnlbLZZPVBfXbp2ulBAPqjeHLTd02P5Vpv/1sPGWDptu6bD5lg4rt3RY/eTDetod9lR8L11634vRPrELb9cc3q85fLnm8PWKw+dwzeHjNYdPlxze8ja8HYTv+X8kd5Gr1RO1rmXbd/dVmiTdTPJ9Jkczuegr9UwzuejL7kwzuehr6DwzkYu+3c40k4u+NM80k/tdfDyT+118PBO5z+RoJve/T/Zn0r74OXqdjB6m4/W35tefvc0euy/Rty+Xv17eP2lr/wA="}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::constructor_parameters"}}],"kind":"struct","path":"TokenBridge::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_private_parameters"}}],"kind":"struct","path":"TokenBridge::claim_private_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::get_token_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_public_parameters"}}],"kind":"struct","path":"TokenBridge::claim_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi"},{"fields":[{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi"}]}},"file_map":{"100":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<let N: u32>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n"},"103":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"104":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"105":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"108":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n"},"109":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"113":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"114":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"117":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{enqueue_public_function_call_internal, set_public_teardown_function_call_internal}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"121":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"122":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"126":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n"},"132":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr","source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n"},"134":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n"},"149":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"156":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"168":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // Intended to be only called once. \n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, UnconstrainedContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, T_SERIALIZED_LEN> SharedImmutable<T, &mut PrivateContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"171":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"173":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"175":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n"},"197":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"205":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"206":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes = max_value.to_be_bytes(32);\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"216":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"222":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"23":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"237":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n"},"24":{"path":"std/field/mod.nr","source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n"},"266":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"267":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"},"27":{"path":"std/hash/mod.nr","source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n"},"283":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n"},"284":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n"},"305":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n"},"306":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all"},"309":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk, from));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all"},"32":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n"},"323":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr","source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"},"34":{"path":"std/merkle.nr","source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n"},"43":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n"},"49":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"52":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"60":{"path":"/home/ayush/Code/Defi-Bridge/src/main.nr","source":"contract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress,\n        amount: Field,\n        caller_on_l1: EthAddress,\n        nonce: Field\n    ) {\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field,\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field\n    ) {\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress,\n        amount: Field,\n        caller_on_l1: EthAddress,\n        nonce: Field\n    ) {\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n}\n"},"76":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\npub fn compute_inner_note_hash<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"90":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/keys/getters.nr","source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point { x: x_coordinate, y: y_coordinate, is_infinite: false }\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n"},"93":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n"},"97":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n"},"98":{"path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n"}}}