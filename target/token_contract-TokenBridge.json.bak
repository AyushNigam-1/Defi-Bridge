{"noir_version":"0.32.0+92ff2fa2e944722e5c3fa43fb3363f093b8f1d12","name":"TokenBridge","functions":[{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2c20/bMBjFk9JyS5q2tGUt1wCDvaaUy/YGD3tl0vYyaU+FphMao1MLE/vvh9N8cGo5lSNsEktEQnUS+zs/H1/qmKi2NTkKj392nC7BNf6gPGfxZ/Cyo6MwVqCT01bIaQNngWCLeIGrBKaxofB+CCft+PN8NOr9869v++GDP7y/84cD/3J4f9sfP5X8FScWOaWiqup+DLrzIMB3qag28b2nz/jPwfzxPXZtzprOv/B8e1KG06rBNar38uNfNU73/v7+8udq2A/P+/1ROB6jq0VrulzSIRuvlCJei493cX9zcz24DkefH67Hd1Nx5wVxWbpgTXteFLCIhjk7Fq3p+rN8Z/F58LIjGk4lYCpAHYqgvwT6yvpkEAxYP1ng6su3CXq1BEyLepg6GusbsNjLWtryKKSxir4tcL55kGcZvHQ0eWmDNjHRuZOgr86TkwGL50p44gqY3Aw8cRP01XlyesTilSU8KQuYyhl4Uk7QV+fJYbQU8CQ88QRMXgaeeAn6CsfOJxavIuFJRcBUycCTSoK+Qk+iObYq4UlVwFTNwBPUTMPtGcrtGsqdF795fYVjJ9KvSXhSEzDVMvCklqCv0JMrFm9FwpMVAdNKBp6gZhpuLyfcvL7CdVWPxatLeFIXMNUz8KSeoK+wfx+zeA0JTxoCpkYGnjQS9BV6Eq2/mxKeNAVMzQw8acI12isYaWfqBA7HRBoWx2lxnA6kcb9gFWKUlHEGAbbVKui90+LLpK34/kPn7/TrD1jstqa6sdhremJHz3jrcaxSHHtN4NsG6Cvcbu6gPsUmrXVoS0oPIS/lozw0XxA/ex6lfcqNGeWaXDkP8rSg3BpXjs6p3Zl/YZzW2ddk+jpbJ4rWsbjHq7odcY+Unc+BL6SvZw+xG82Lq9b0Ibtnquv7Q/eeKfYvhXumJyxei/NtlfPNgzw4T7Q0eTnru7iVoK9wHRut2doSnrQFTLq+F2Z5gpppuCs54eb1Fa41u6K5XOTJmoBJ0/fwTE9QMw23ayi3Zyi3Yyh3xVDuck64eX2Fc9Upro9nebIuYFrPwBPUTMNdN5TbzQk3r6+uDx4PRM9MIk82BEwbGXgy61lvFrdrKLeTE25eX+E8eMnibUp4silg2szAE9RMw103lLtiKHfZUO62odxVQ7nf+vfrcjuGcpvaT2o54eb1Fe7hRe9ubUl4siVg2srAE9RMw13OCTevr3A9eMjibUt4si1g2s7AE9RMw103lLtsKHfbUO6qody1N+5X5TZ1PmkYyp2XeZDXV7iuiv6f5kt44guY/Aw8QU0/BbdrKHfVUG5T/fYM5W4bym1q/669cb8q92ZOuNk1elfuh62bqdtJ+86wH386kF4C73Yghup3hklvB/R2tfgyaSuf84DOd7Xrd6N3+N5rqhuLva8ndvTO8EEci94Z3hf49gH0bcXtdsDFJq0DaEtKf7ef81I+ykPzBfGz9fpenEZ+vpzPlfMgzx6U2+fK0Tm1O/PvAuYAXX1Npq/jO8Md65lpDsqdKeGZ9E9d45rNW/PW9DFrvsM+u6OJif2uAD3DPv1mxre74aj3M/wa9vo26PK/l4GfdkK9CnBtTpAuWOKD1XlPT521zm84tmgOonqQJo63QWxUVeCBaJxSG1BMNi9QP6G8rJ9Rf9mFa+Q13WNj6j9N8uWZy0gAAA==","debug_symbols":"5ZzdaltHFEbfRdemzHx79vz4VUopSuIUg5FD7BSK6btXbiSroQKzCF9A8ZUte/Zwxot1szycp82Hm3df/vj9dvfx/mFz/evT5u7+/fbx9n63//S0Kb/Mf3/48Gm7e/788Lj9/Li5Llebm92H/de/rzYfb+9uNtd9/+3/lq3Mw8I1xsvSWuPM2hbqh8UtIk+r1c+s7i3XYXVv49vVv13tH3t9x2PXEjqsrCXbj33wWr7nD77q6cHzlQevKu24Wr288uCjr3FYPUYrZx68eh786+Zybh7OzZtz83Ru3p2bD+fm07n5Mm6u4tzcaaichsppqJyGymmonIbKaaichsppaDgNDaeh4TQ0nIaG09BwGhpOQ8NpaDgNDaehzWlocxranIY2p6HNaWhzGtqchjanoc1paHMamk5D02loOg1Np6HpNDSdhqbT0HQamk5D02lodxranYZ2p6HdaWh3Gtqdhnanod1paHca2p2GDqehw2nocBo6nIYOp6HDaehwGjqchg6nocNp6HQaOp2GTqeh02nodBo6nYZOp6HTaeh0Gjqdhi6noctp6HIaupyGLqehy2nochq6nIYup6HLaWgtxbq79c5CsV5aKNZbC6VZd7feWyjWiwvFenOhWK8uFKur1eqq936R94KR94YRuGJ0GEg60OnAoAOTDiw4AK7WHAYqHRAdCDpASYuSFiUtSlqUtCjpoKSDkg5KOijpoKSDkg5KOijpoKSDkm6UdKOkGyXdKOlGSTdKulHSjZJulHSjpJOSTko6KemkpJOSTko6KemkpJOSTkq6U9Kdku6UdKekOyXdKelOSXdKulPSnZIelPSgpAclPSjpQUkPSnpQ0oOSHpT0oKQnJT0p6UlJT0p6UtKTkp6U9KSkJyU9KelFSS9KelHSi5JelPSipBclvSjpRUkvSFql0IFKB0QHgg40OpB0oNOBQQcmHaCkKyVdKelKSVdKmjYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZEEbWdBGFrSRBW1kQRtZ0EYWtJEFbWRBG1nQRha0kQVtZEEbWdBGFrSRBW1kQRtZ0EYWtJEFbWRBG1nQRha0kQVtZEEbWdBGFrSRBW1kQRtZ0EYWtJEFbWRBG1nQRha0kQVtZEEbWdBGFrSRBW1kQRtZ0EYWtJEFbWRBG1nQRha0kcX5Rrb/l+/xtaD7/83mf8fOvKSyluNrJ2vN+rK45rmXVGbO4+rs0mn12VdaZouX1a3HK6vnyON7Pucs9ZvVh+POt3Xc9aaOe76u/rzHrW/ruHpbx40fftyh03FfO0Ct/bT36KfV4+Wlfe3SD5CXfoB+6QcYl36AeekHWJd7gP2nP7efb7fv7m6e35T//Msvu/fHF+fvPz7+9enrb/Zr/wE="},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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4jSnWZyzze3iNKdbnOZ0i9OcbvFA3CxOc7rFaU63OM3pFqc53eI0p1l8oTnd4jSnW5zmdIvTnG7xQNwsTnO6xWlOtzjN6RanOd3iNKdZfKU53eI0p1uc5nSL05xu8UDcLE5zusVpTrc4zekWpznd4jSnWXxjHk8V39b9sds6t7yZxr3egbfVm0nc680c7vVmCvd6M4N7vZnAnd5l4D0frzfv+Hi96UuvN33p9Q68rd70pdebvvR605deb/rS601f5r7DMwzloCvREC8UplucxnSLU5lucTrTLR6Im8VpTbc4tekWpzfd4hSnW5zmNItXmjNZvKwH3Vha4jSnW5zmdIvTnG7xQNwsTnO6xWnO502HbXGa0z2P05xucZrTLD7SnG5xmtMtTnO6xWlOt3ggbhanOd3iNKdbnOZ0i9OcbnGa0yweNKdbnOZ0i9OcbnGa0y0eiJvFaU63OM3pFqc53eI0p1uc5jSLTzSnW5zmdIvTnG5xmtMtHoibxWlOtzjN6RanOd3iNKdbnOY0i880p1uc5nSL05xucZrTLR6Im8VpTrc4zekWpznd4jSnW5zmNIsvNKdbnOZ0i9OcbnHm8VTxtUxfHruWreXNNJ7rfax4nZaWN7O415tJ3Oq9MqN4vZlQvN7siXu9A2+rN/O315v52+vN/O31Zv72erMPbvXe2AX3etOXXm/60utNX+Z6H4tY19b+9xZ4W73pS683fen1pi+93vSl15u+dHrXgb70etOXXm/60utNX3q9A2+rN33p9aYvvd70pdebvvR605dW70Jfer3pS683fen1pi+93oG31Zu+9HrTl15v+tLrTV96velLq3elL73e9KXXm770etOXXu/A2+pNX3q96UuvN33p9aYvvd70pdV7pC+93vSl15u+9HrTl17vwNvqTe94vekdrze94/Wmd6zeQe94vW85D749dP+c7nFZSsslcGm63PL1flyH2F3WUlsut3xd/g6XW75+nrtMt3yd+w6XW+6/fYfLLffJvsPlnvPLuUvg0nS55b8/+A6XW+6bfYcL827bhXm37cK823S55wnu3+HCvNt2Yd5tuzDvtl0Cl6YL827bhXm37cK823Zh3m27MO82Xe55evR3uNxz3l224eFy8pbt34a8fc11aSLeczhORrzpO9+5iAGijnjPGT0Z8Z4DfTLiPaf/ZMR7pkIy4j27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"},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2bW2/bRhCFSVW+JJIoSpF808Wynbi+JCll2Un6UCB56GsLtL/AsaTCQBoVsl0kQAv0uUCf259bL82xj6crhUR3RQ4iAoZIeXfOx7PD4WpBus7Nlrv+c6P9hejzC+e/G7V5HX0G/2/rGowV2OR0hXDmbHAqyLwmKdwocSYliQvf/Q0H69Hnm/H49GPn/H1/8KEzurrsjIadt6Or9/2L256/R+GXWfS8qdN8FfQWQYCnfHhZRP+7/Yz+Cg6cffS/AsRw4TtyLxd9t3TXxamoPsv3dR9e//nR/umvP3//y9moP3jT748HFxfo6gJ4Mm2LG28xQbw1Hu+7q3fvzofng/G3H84vLu/FXdLEpezJac4HWXQZprZl5/75G0z98HIn/XwUe4kxLkc+kL6xnAyCYcG5n/OkgVse9h8C0wM7TF2L5xuo2AUrY3k8UPGKzLdl5psHbQrgZdGSly5oExMdFyfom/PkxVDFK8XwpKRhKqXgSWmCvjlPXh670Tl/yhNPw+Sl4Ik3Qd+cJ0eBileO4UlZw1ROwZPyBH2D187XKp4fwxNfw+Sn4Ik/Qd+gJ2GNrcTwpKJhqqTgCWom4S4L5S4J5c6K31zf4LUT6ldjeFLVMFVT8KQ6Qd+gJ2cq3qMYnjzSMD1KwRPUTMJdzgg31zc4rzpV8WoxPKlpmGopeFKboG8wv09UvHoMT+oapnoKntQn6Bv0JJx/r8TwZEXDtJKCJyvwHa0VjK0zdYMCYyINh3E6jLMA+7hesAoxFoxxBgGO1SrorVnx5WaseP7Q8Zp9/aGKvWHp3FTshp3Y4W+8ZhRrIYrd0PjWAn2Dy+Fd1KfYpNWEsaT9EbSldtSG6gXxq3kvrTa3pvRbYf08aLMO/RqsHx3TuCv/BtG+zVyLk+vqNxb/DaiOac5xu2774+B6BX78qeVa3WZ6WVltVCoWgIP627O0d4bl0QEN3LCs4qVhaVm0azGFwiVXTG2DS64vVLwN5htPTw/arIOXtkqoC9rERMcbE/QNToNPdOVD50lDw2Sp9E/1BDWTcPsZ4eb6BqeqPbxlTfOkqWFqpuAJaibhLgnlLgvlLgrl9oVyexnh5vrmatXJcNp0Fz1paZhaKXgSZ5qu465khJvrG5xDhPeddgxP2hqmdgqeoObnwF3LCDfXN5iDRyreZgxPNjVMmyl4gppJuEtCuZtCuaX6XcwIN9c3+HvnrYrXieFJR8PUScET1Owk4K4J5faFcjeFcpeFcreEckvNE6l+VzLCzfUN3tP6Kt5WDE+2NExbKXiCmkm4a0K5PaHcDaHcFaHcvlBuqfldFMotNU+qGeHm+gbXlMJH6rdjeLKtYdpOwRPUTMLtZYSb6xucV4XrgzsxPNnRMO2k4AlqJuGuCeX2hHI3hHJXhHJX59wz5ZZaT+pCuaXWwbJQbl8od0kot9R60hbKLTW/5/OTOXcc7q2McKvv6B2Bv1zbTL1+gTGRhsM4HcZZgP018O4xxDD9uhXpPQa9J1Z8uRkrnj90/MS6fu9Mxf7S0rmp2Ht2YoevW+1Hseh1qz2Nbweg7xoet30Wm7T2YSxp/0/3ri21ozZUL4hfzZV2o33k5/12WD8P2uxCvz3Wj45p3JV/f0ANsJVrcXJd3f/pOv/GuWNahH6vjfBYfS+oq+rWknN/m1bvsLatWmJS71fRfPbutbXL0fj0p8EPg9O+C7r83TX8dCecVw6+W9Ts5xz9ZrG+hu9n7VryU8XDaygP50GaeWjzT2SUr/EAY1E/GgOKqeoC5Qm2xXf91qA/eWvn/HtB0hzfBSab9xxL4x3w+5nB9wuO8X5Cvi0x3zxoswde7lvy0gVtYqJj1EzCXRTKvSmUuyaU2xfK7Qnlrgjlrs+5Z8rdFsottQ625twz5ZZav8tCued5MltuqfMqqb8bSkK5peZ3Vvzm+gafDXylWwvWeXKgYTpIwZNpa9jTuGtCuT2h3C2h3BWh3B2h3PPrcrbcUvNbaj2Z1+/ZckutJ1K5faHcUq/LslDueZ7Mlltq/S4J5S4K5W4L5c7KPJbrG1ybeaniHcbw5FDDdJiCJ6iZhLuWEW71HT3/9FvONlMvfK4PmUjDYZwO4yzA/i549xRimH6OmfSegt4zK77cjBXPHzp+Zl2/Fz6b9ZWlc1OxAzuxw+eYu1EseoYw0Ph2BPqu4XHrstik1YWxpP2Pubu21I7aUL0gfjUveB7tIz/vd8j6edDmOfQLWD86pnFX/o2gBtjKtTi5rubOdJ2Tdw+u//4FEAluKyp8AAA=","debug_symbols":"5dzhah1HFsTxd9Fns8yc6nO626+yLIuSOIvAyCFWFhaz777K5spKyAXxL+cEFH9KZE8Pd1xVYH4e6dPNd++++elf/7y7//7Dx5u3f/908/7Dt7cPdx/uH7/6dHP8bf3/Fz/+cHv/89cfH25/fLh5e7y5eXf/3eN///vm5vu79+9u3tbj//7usp15uXDP+fnS89SVa4eiLhcPKZ+vjrpydY3cl6trzN9e/Y83jx97f8HHPg/F5crzyPHnfvDz+JI/8H0+f/B84YOfcYynq6OOFz74rD0vV885jisf/Oz54L/cPDpvrs6bj86bZ+fNq/Pms/Pmq/Pmu/HmcXTevHOh0bnQ6FxodC40OhcanQuNzoVG50Kjc6HqXKg6F6rOhapzoepcqDoXqs6FqnOh6lyoOhc6Ohc6Ohc6Ohc6Ohc6Ohc6Ohc6Ohc6Ohc6Ohc6OheanQvNzoVm50Kzc6HZudDsXGh2LjQ7F5qdC83OhVbnQqtzodW50OpcaHUutDoXWp0Lrc6FVudCq3Ohs3Ohs3Ohs3Ohs3Ohs3Ohs3Ohs3Ohs3Ohs3Ohs3Ohq3Ohq3Ohq3Ohq3Ohq3Ohq3Ohq3Ohq3Ohq3Ohq3Ohu3Ohu3Ohu3Ohu3Ohu3Ohu3Ohu3Ohu3Ohu3Ohu3Oh53G03r31nYWj9aWFo/WthWO03r31vYWj9cWFo/XNhaP11YWjdatn61Z73y/qfcGo9w2jL3rFaIz19ELaGPtXb+ldf32tzqf7VsW119e+6JWkP/pdOvAK0+XApAcWPbDhAfBK0OXASQ8EPSB6YNADSQ/QpIMmHTTpoEmLJi2atGjSokmLJi2atGjSokmLJi2a9KBJD5r0oEkPmvSgSQ+a9KBJD5r0oEkPmnTSpJMmnTTppEknTTpp0kmTTpp00qSTJl006aJJF026aNJFky6adNGkiyZdNOmiSU+a9KRJT5r0pElPmvSkSU+a9KRJT5r0pEkvmvSiSS+a9KJJL5r0okkvmvSiSS+a9KJJb5r0pklvmvSmSW+a9KZJb5r0pklvmvSGScdx0AMnPRD0gOiBQQ8kPVD0wKQHFj1Akz5p0idN+qRJnzTpkyZ90qSpkQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIghpZUCMLamRBjSyokQU1sqBGFtTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M140sHv/15nImHtH318eu/Ljz83j6Aebnmefni8+89r1lmevp6qyI56uvfidaDn2+epReuHrNfPout7WO8zdXXx53fV2Pu7+mxx3XdfWv+7jn1/W48XU9rv70x53x/LgvPcB51vO9Zz1fPT//tODx2h8gX/sD1Gt/gPnaH2C99gfYr/wBzpf/TrD1u78Xj/P0joV3TN6x4R1L71h5x6Z3bHnHtnUsvJaE15LwWhJeS8JrSXgtCa8l4bUkvJaE1xJ5LZHXEnktkdcSeS2R1xJ5LZHXEnktkdeS4bVkeC0ZXkuG15LhtWR4LRleS4bXkuG1ZHgtSa8l6bUkvZak15L0WpJeS9JrSXotSa8l6bWkvJaU15LyWlJeS8prSXktKa8l5bWkvJaU15LptWR6LZleS6bXkum1ZHotmV5LpteS6bVkei1ZXkuW15LltWR5LVleS5bXkuW1ZHktWV5LlteS7bVkey3ZXku215LttWR7LdleS7bXku21ZFstyePwjp3esfCOyTs2vGPpHSvv2PSOLe+Y1xLPXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX8uy1PHstz17Ls9fy7LU8ey3PXsuz1/LstTx7Lc9ey7PX8uy1PHstz17Ls9fy7LU8ey3PXsuz1/LstTx7Lc9ey7PX8uy1PHstz17Ls9fy7LU8ey3PXsuz1/LstTx7Lc9ei9vr4xf/vv3x7vab9+8+Ph75+fd+uv/24e7D/eXLh//88MvvPF77Pw=="},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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6MTjMhl5bZm+Zxnbswz2LON7lhl7lok9y+SeZeaeZdaWZWxPCtieFLA9KfAVx8gd/3uZ1XEO6GVftP70K6MtbJ6nzpifjb7ab4k8C5lu64vRpw340Tcwjr6BOPoG8ugbmEffwDr4Br6ilUF8A/3oG7Cjb+Dob+KvaMEQ38DR38Q4+psYR38T4+hvYhz9TexHfxP70d/EfvQ3sR/9TfwV7TTiGzj6m9iP/ib2o7+J/ehvYt/+Jp7z/NlmNte8Imk0PUldT5LpSYKeJNeTNPQkhZ6k1JM09STppXfopXfopXfopXfopXfopXfopXfopXfopXfopXfopXfqpXfqpXfqpXfqpXfqpXfqpXfqpXfqpXfqpXfqpffUS++pl95TL72nXnpPvfSeeuk99dJ76qX31EvvqZfeSy+9l156L730XnrpvfTSe+ml99JL76WX3ksvvZdcekeTS+9ocukdTS69o8mldzS59I4ml97R5NI7mlx6R5NL72h66d310rvrpXfXS++ul95dL727Xnp3vfTueund9dK766W36aW36aW36aW36aW36aW36aW36aW36aW36aW36aU39NIbeukNvfSGXnpDL72hl97QS2/opTf00ht66e166e166e166e166e166e166e166e166e166a3Xaxl6vZah12sZer2WoddrGXq9lqHXaxl6vZah12sZer2WoddrGXq9lqHXaxl6vZah12sZer2WoddrGXq9lqHXaxl6vZaR3+D2ixu3qUR2QU0mqEnvdp74Bjcs3tY0BDWFoKYU1DQFNS09TVMwx6dgjk/BHJ+COf4N7lq8dTtPTL1bjGLq3WIUU+82uph6t9HF1LuNLpbebXSx9G6ji6V3G10svdvoYgnm+BLM8SWY44K3iobgraIheKtoCt4qmoK3iqbgraIpeKtoNr0cT8FbRVPwVtFsejmeTS/HswnmeBfM8S6Y410wx7tgjnfBHO+COd4Fc7wL5ngXzPFnuTx1jIumMdctTTd4ZhoENbmgpiGoKQQ1paCmKahp6WlCE9TUBTUJ5jgEcxyCOQ7BHMc3yPFb36sgBTVNQU1LT5M3QU1dUJMJaoKgJhfUNAQ1Cea4C+a4C+a4C+b4EMzxIZjjQzDHh2COD8EcH4I5PgRzfAjm+BDM8SGY4yGY4yGY4yGY4yGY4yGY4yGY4yGY4yGY4yGY4yGY46mV4w9f/PPVr29e/fD29fuHR/74vd/uf/zw5t396csP//rl0+88jP03"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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lGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWjlGWj9CY2Ki8up/VtuVq/IcaqHqeTtYuTleUkJo0k5pZXhJzS6Sc+dY/yHn4PrVdLD7/eF1dLt++QelpVuGe7mj5Kl5t+Hpu9QXpZfVpKWz+LetsvaT5LKVu/fY1d7+z6wq6v7PqGrveFXZ/Y9ZldL+x6NrXOptbZ1DqbWmdT62xqC5vawqa2sKktbGoLm9rCprawqS1sagub2sKmtrKprWxqK5vayqa2sqmtbGorm9rKprayqa1sahub2samtrGpbWxqG5vaxqa2saltbGobm9qGptaWhV2f2PWZXS/semXXG7ve2fWFXV/Z9WxqE5vaxKY2salNbGoTm9rEpjaxqU1sahOb2sSmNrOpzWxqM5vazKY2s6nNbGozm9rMpjazqc1saoVNrbCpFTa1wqZW2NQKm1phUytsaoVNrbCpVTa1yqZW2dQqm1plU6tsapVNrbKpVTa1yqbW2NQam1pjU2tsalk2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylg2ylk2ylk2ylk2ylk2yhdl1xu73tn1hV1f2fVsalk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2ylk2yrfZKK3rfdLLk6ObP0TKLR1nk6icfwjbOqxqta7T1i4vn26eYbUiq3wrXjrTtZ6uqtYm19NHszmSWYlkViOZtUhmPZLZEslsjWS2BTK7TYbOajZSg7qJmrW0/usBJvWqi/55ViWvV+9VxDrCD39FsF73P/x5u20Jv+X9nenpF7N2r/VnWV1qttoRXkpbhZcq6Vr44at/Pv769PjD509fD9/nj2/87fnHl6cvz8cvX/71y+u3HGb/DQ=="},{"name":"transfer_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"item","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_stack_item_compressed::PublicCallStackItemCompressed","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"revert_code","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"start_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"end_gas_left","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::transfer_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::transfer_public_parameters","fields":[{"name":"from","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e93e0ef"},{"kind":"string","value":"TransparentNote"}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000edf2744b"},{"kind":"string","value":"TokenNote"}]}],"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}]}},"file_map":{"24":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"27":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod keccak;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    __pedersen_hash_with_separator(input, separator)\n}\n\nfn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constraint the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::from_slice(domain_generators.as_slice());\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    __pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n    // Same as from_field but:\n    // does not assert the limbs are 128 bits\n    // does not assert the decomposition does not overflow the EmbeddedCurveScalar\n    fn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = crate::field::bn254::decompose_hint(scalar);\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n\n","path":"std/hash/mod.nr"},"32":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\nglobal RATE: u32 = 3;\n\nstruct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) -> [Field; RATE] {\n        // zero-pad the cache\n        for i in 0..RATE {\n            if i >= self.cache_size {\n                self.cache[i] = 0;\n            }\n        }\n        // add the cache into sponge state\n        for i in 0..RATE {\n            self.state[i] += self.cache[i];\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n        // return `RATE` number of field elements from the sponge state.\n        let mut result = [0; RATE];\n        for i in 0..RATE {\n            result[i] = self.state[i];\n        }\n        result\n    }\n\n    fn absorb(&mut self, input: Field) {\n        if (!self.squeeze_mode) & (self.cache_size == RATE) {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            let _ = self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else if (!self.squeeze_mode) & (self.cache_size != RATE) {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        } else if self.squeeze_mode {\n            // If we're in squeeze mode, switch to absorb mode and add the input into the cache.\n            // N.B. I don't think this code path can be reached?!\n            self.cache[0] = input;\n            self.cache_size = 1;\n            self.squeeze_mode = false;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        if self.squeeze_mode & (self.cache_size == 0) {\n            // If we're in squeze mode and the cache is empty, there is nothing left to squeeze out of the sponge!\n            // Switch to absorb mode.\n            self.squeeze_mode = false;\n            self.cache_size = 0;\n        }\n        if !self.squeeze_mode {\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\n            // matched\n            let new_output_elements = self.perform_duplex();\n            self.squeeze_mode = true;\n            for i in 0..RATE {\n                self.cache[i] = new_output_elements[i];\n            }\n            self.cache_size = RATE;\n        }\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\n        let result = self.cache[0];\n        for i in 1..RATE {\n            if i < self.cache_size {\n                self.cache[i - 1] = self.cache[i];\n            }\n        }\n        self.cache_size -= 1;\n        self.cache[self.cache_size] = 0;\n        result\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\nstruct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field)*18446744073709551616;    // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field){\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher {\n            _state: &[],\n        }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"34":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"43":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"49":{"source":"use crate::append::Append;\n\nimpl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T where T: Append {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"52":{"source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\nuse crate::println;\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\nstruct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_be_bytes(8);\n        let hi = self.hi.to_be_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo = self.lo.to_le_bytes(8);\n        let hi = self.hi.to_le_bytes(8);\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    fn decode_ascii(ascii: u8) -> Field {\n        if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (U128::uconstrained_check_is_upper_ascii(ascii) as u8);\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        } as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;  \n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi*b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo*b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo+self.hi)*(b.lo+b.hi) - low + carry\n        } else {\n            self.lo*b.hi + self.hi*b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 {\n            lo,\n            hi,\n        }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        q\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        let (q,r) = self.unconstrained_div(b);\n        let a = b * q + r;\n        assert_eq(self, a);\n        assert(r < b);\n        r\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n        \n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 { \n    fn not(self) -> U128 {\n        U128 {\n            lo: (!(self.lo as u64)) as Field,\n            hi: (!(self.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitOr for U128 { \n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 { \n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 { \n    fn shl(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    } \n}\n\nimpl Shr for U128 { \n    fn shr(self, other: u8) -> U128 { \n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits = (other as Field).to_be_bits(7);\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            y = (exp_bits[7-i] as Field) * (r * y) + (1 - exp_bits[7-i] as Field) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    } \n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c= b.to_le_bytes(17);\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        let (q,r) = a.unconstrained_div(b);\n        assert_eq(q, c);\n        assert_eq(r, d);\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        let (c,d ) = a.unconstrained_div(b);\n        assert_eq((c, d), (a, U128::zero()));\n\n        // Check where b is a multiple of a\n        let (c,d) = b.unconstrained_div(a);\n        assert_eq((c, d), (U128::zero(), b));\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        let (c,d)= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::zero(), U128::zero()));\n\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        let (c,d )= a.unconstrained_div(b);\n        assert_eq((c, d), (U128::one(), U128::zero()));\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n","path":"std/uint128.nr"},"60":{"source":"contract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n    }\n\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress) {\n        storage.token.write(token);\n    }\n \n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field) {\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        Token::at(storage.token.read()).transfer_public(from, to, amount, nonce).call(&mut context);\n    }\n\n    #[aztec(public)]\n    fn exit_to_l1_public(sender: AztecAddress, amount: Field, nonce: Field) {\n        Token::at(storage.token.read()).burn_public(sender, amount, nonce).call(&mut context);\n    }\n\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field,\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field\n    ) {\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress,\n        amount: Field,\n        caller_on_l1: EthAddress,\n        nonce: Field\n    ) {\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n}\n","path":"/home/ayush/Code/Defi-Bridge/src/main.nr"},"76":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    constants::GENERATOR_INDEX__INNER_NOTE_HASH,\n    hash::{\n    pedersen_hash, compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_inner_note_hash_from_preimage(storage_slot: Field, note_content_hash: Field) -> Field {\n    pedersen_hash(\n        [storage_slot, note_content_hash],\n        GENERATOR_INDEX__INNER_NOTE_HASH\n    )\n}\n\npub fn compute_inner_note_hash<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    compute_inner_note_hash_from_preimage(header.storage_slot, note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, let N: u32, let M: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N, M> {\n    let header = note_with_header.get_header();\n    let (_, inner_nullifier) = note_with_header.compute_note_hash_and_nullifier(context);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\nfn compute_note_hash_for_read_request_from_innter_and_nonce(\n    inner_note_hash: Field,\n    nonce: Field\n) -> Field {\n    // TODO(#1386): This if-else can be nuked once we have nonces injected from public\n    if (nonce == 0) {\n        // If nonce is zero, that means we are reading a public note.\n        inner_note_hash\n    } else {\n        compute_unique_note_hash(nonce, inner_note_hash)\n    }\n}\n\npub fn compute_note_hash_for_read_request<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let inner_note_hash = compute_inner_note_hash(note);\n    let nonce = note.get_header().nonce;\n\n    compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, nonce)\n}\n\npub fn compute_note_hash_for_consumption<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N, M> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    if (header.note_hash_counter != 0) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        inner_note_hash\n    } else {\n        // If a note is not transient, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the siloed_note_hash which has already been hashed with\n        // nonce and then contract address. This hash will match the existing leaf in the note hash\n        // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, header.nonce);\n        compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let M: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N, M> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n    let unique_note_hash = compute_note_hash_for_read_request_from_innter_and_nonce(inner_note_hash, note_header.nonce);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        let (_, nullifier) = note.compute_note_hash_and_nullifier_without_context();\n        nullifier\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [inner_note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"90":{"source":"use dep::protocol_types::{\n    header::Header, abis::validation_requests::KeyValidationRequest, address::AztecAddress,\n    constants::CANONICAL_KEY_REGISTRY_ADDRESS, point::Point, storage::map::derive_storage_slot_in_map,\n    traits::is_empty\n};\nuse crate::{\n    context::PrivateContext,\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, INCOMING_INDEX, OUTGOING_INDEX, TAGGING_INDEX}},\n    state_vars::{shared_mutable::shared_mutable_private_getter::SharedMutablePrivateGetter}\n};\n\nglobal DELAY = 5;\n\n// docs:start:key-getters\ntrait KeyGetters {\n  fn get_npk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ivpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_ovpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_tpk_m(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Point;\n  fn get_npk_m_hash(header: Header, context: &mut PrivateContext, address: AztecAddress) -> Field;\n}\n\nimpl KeyGetters for Header {\n    fn get_npk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, NULLIFIER_INDEX, self)\n    }\n\n    fn get_ivpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, INCOMING_INDEX, self)\n    }\n\n    fn get_ovpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, OUTGOING_INDEX, self)\n    }\n\n    fn get_tpk_m(self, context: &mut PrivateContext, address: AztecAddress) -> Point {\n        get_master_key(context, address, TAGGING_INDEX, self)\n    }\n\n    fn get_npk_m_hash(self, context: &mut PrivateContext, address: AztecAddress) -> Field {\n        get_master_key(context, address, NULLIFIER_INDEX, self).hash()\n    }\n}\n// docs:end:key-getters\n\nfn get_master_key(\n    context: &mut PrivateContext,\n    address: AztecAddress,\n    key_index: Field,\n    header: Header\n) -> Point {\n    let key = fetch_key_from_registry(context, key_index, address, header);\n    if is_empty(key) {\n        // Keys were not registered in registry yet --> fetch key from PXE\n        let keys = fetch_and_constrain_keys(address);\n        // Return the corresponding to index\n        keys.get_key_by_index(key_index)\n    } else {\n        // Keys were registered --> return the key\n        key\n    }\n}\n\nfn fetch_key_from_registry(\n    context: &mut PrivateContext,\n    key_index: Field,\n    address: AztecAddress,\n    header: Header\n) -> Point {\n    let x_coordinate_map_slot = key_index * 2 + 1;\n    let y_coordinate_map_slot = x_coordinate_map_slot + 1;\n    let x_coordinate_derived_slot = derive_storage_slot_in_map(x_coordinate_map_slot, address);\n    let y_coordinate_derived_slot = derive_storage_slot_in_map(y_coordinate_map_slot, address);\n\n    let x_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        x_coordinate_derived_slot\n    );\n    let y_coordinate_registry: SharedMutablePrivateGetter<Field, DELAY> = SharedMutablePrivateGetter::new(\n        context,\n        AztecAddress::from_field(CANONICAL_KEY_REGISTRY_ADDRESS),\n        y_coordinate_derived_slot\n    );\n    let x_coordinate = x_coordinate_registry.get_value_in_private(header);\n    let y_coordinate = y_coordinate_registry.get_value_in_private(header);\n\n    Point { x: x_coordinate, y: y_coordinate, is_infinite: false }\n}\n\n// Passes only when keys were not rotated - is expected to be called only when keys were not registered yet\nfn fetch_and_constrain_keys(address: AztecAddress) -> PublicKeys {\n    let (public_keys, partial_address) = get_public_keys_and_partial_address(address);\n\n    let computed_address = AztecAddress::compute(public_keys.hash(), partial_address);\n\n    assert(computed_address.eq(address));\n\n    public_keys\n}\n\n// A helper function since requesting nsk_app is very common\n// TODO(#6543)\npub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/keys/getters.nr"},"93":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<let N: u32>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"98":{"source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n}\n\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"103":{"source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr"},"104":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"108":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub fn get_key_validation_request(pk_m_hash: Field, key_index: Field) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"109":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"113":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/initializer.nr"},"117":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{enqueue_public_function_call_internal, set_public_teardown_function_call_internal}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, gas::Gas,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, public_call_stack_item::PublicCallStackItem,\n    public_call_stack_item_compressed::PublicCallStackItemCompressed, read_request::ReadRequest,\n    note_hash::NoteHash, nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        let call_request = PublicCallRequest { item, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = PublicCallStackItemCompressed {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash: 0,\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty()\n        };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            item,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"121":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\ntrait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        assert(self.args_hash == pack_arguments(self.args));\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        assert(self.args_hash == pack_arguments(self.args));\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n}\n\nstruct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n}\n\nstruct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        assert(args_hash == pack_arguments(self.args));\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"122":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"126":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<let N: u32>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N as Field)\n}\n\nunconstrained fn storage_write<let N: u32>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<let N: u32>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<let N: u32>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"132":{"source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr"},"149":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH, MAX_ARGS_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, let N: u32, let M: u32>(\n    contract_address: AztecAddress,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[36 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() <= MAX_ARGS_LENGTH, \"Args length exceeds maximum\");\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..MAX_ARGS_LENGTH {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x11e40f2a780822f7971803048c9a2100579de352e7dadd99981760964da65b57);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/hash.nr"},"156":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, T_SERIALIZED_LEN> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"173":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"175":{"source":"use crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u1 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u8 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u32 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for u64 { fn to_field(self) -> Field { self as Field } }\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\ntrait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool { fn from_field(value: Field) -> Self { value as bool } }\nimpl FromField for u1 { fn from_field(value: Field) -> Self { value as u1 } }\nimpl FromField for u8 { fn from_field(value: Field) -> Self { value as u8 } }\nimpl FromField for u32 { fn from_field(value: Field) -> Self { value as u32 } }\nimpl FromField for u64 { fn from_field(value: Field) -> Self { value as u64 } }\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for [Field; N] {\n    fn serialize(self) -> [Field; N] {\n        self\n    }\n}\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let mut result = [0; N];\n        let bytes: [u8; N] = self.as_bytes();\n        for i in 0..N {\n            result[i] = field_from_bytes([bytes[i];1], true);\n        }\n        result\n    }\n}\n\n// docs:start:deserialize\ntrait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for [Field; N] {\n    fn deserialize(fields: [Field; N]) -> Self {\n        fields\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"197":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"205":{"source":"struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"216":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"237":{"source":"use crate::{constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize}, point::Point};\n\nstruct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: Point::empty(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x:fields[0], y: fields[1], is_infinite: fields[2] as bool},\n            sk_app: fields[3],\n        }\n    }\n}\n\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"266":{"source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr"},"267":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"283":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"305":{"source":"use dep::aztec::{\n    prelude::{AztecAddress, NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash},\n    note::utils::compute_note_hash_for_consumption, oracle::unsafe_rand::unsafe_rand,\n    keys::getters::get_nsk_app\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\nglobal TOKEN_NOTE_LEN: Field = 3; // 3 plus a header.\n// TOKEN_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TOKEN_NOTE_BYTES_LEN: Field = 3 * 32 + 64;\n\n#[aztec(note)]\nstruct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NoteInterface<TOKEN_NOTE_LEN, TOKEN_NOTE_BYTES_LEN> for TokenNote {\n    // docs:start:nullifier\n    fn compute_note_hash_and_nullifier(self, context: &mut PrivateContext) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n    // docs:end:nullifier\n\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            secret,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        Self {\n            amount,\n            npk_m_hash: owner_npk_m_hash,\n            randomness: unsafe_rand(),\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) &\n        (self.npk_m_hash == other.npk_m_hash) &\n        (self.randomness == other.randomness)\n    }\n}\n","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr"},"306":{"source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::{note_getter_options::PropertySelector, utils::compute_note_hash_for_consumption},\n    prelude::{NoteHeader, NoteInterface, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash}\n};\n\nglobal TRANSPARENT_NOTE_LEN: Field = 2;\n// TRANSPARENT_NOTE_LEN * 32 + 32(storage_slot as bytes) + 32(note_type_id as bytes)\nglobal TRANSPARENT_NOTE_BYTES_LEN: Field = 2 * 32 + 64;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[aztec(note)]\nstruct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nstruct TransparentNoteProperties {\n    amount: PropertySelector,\n    secret_hash: PropertySelector,\n}\n\nimpl NoteInterface<TRANSPARENT_NOTE_LEN, TRANSPARENT_NOTE_BYTES_LEN> for TransparentNote {\n\n    // Custom serialization to avoid disclosing the secret field\n    fn serialize_content(self) -> [Field; TRANSPARENT_NOTE_LEN] {\n        [self.amount, self.secret_hash]\n    }\n\n    // Custom deserialization since we don't have access to the secret plaintext\n    fn deserialize_content(serialized_note: [Field; TRANSPARENT_NOTE_LEN]) -> Self {\n        TransparentNote {\n            amount: serialized_note[0],\n            secret_hash: serialized_note[1],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1386): Ensure nullifier collisions are prevented\n    fn compute_note_hash_and_nullifier(self, _context: &mut PrivateContext) -> (Field, Field) {\n        self.compute_note_hash_and_nullifier_without_context()\n    }\n\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit. \n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_note_hash_and_nullifier_without_context(self) -> (Field, Field) {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let nullifier = poseidon2_hash([\n            note_hash_for_nullify,\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        ]);\n        (note_hash_for_nullify, nullifier)\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n\n    // CUSTOM FUNCTIONS FOR THIS NOTE TYPE\n    // Custom serialization forces us to manually create the metadata struct and its getter\n    pub fn properties() -> TransparentNoteProperties {\n        TransparentNoteProperties {\n            amount: PropertySelector { index: 0, offset: 0, length: 32 },\n            secret_hash: PropertySelector { index: 1, offset: 0, length: 32 }\n        }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr"},"309":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk, from));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n\n        Transfer { from, to, amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier, 0);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_from\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk, from));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk, to));\n    }\n    // docs:end:transfer_from\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all","path":"/home/ayush/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.47.1/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"}}}